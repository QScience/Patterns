<?php


require_once 'includes/config.inc';
require_once 'includes/io.inc';
require_once 'includes/parser.inc';
require_once 'includes/utils.inc';
require_once 'includes/servers.inc';

/**
 * @file
 * Enables extremely simple adding/removing features to your site with minimal to no configuration.
 *
 * It works by reading a pattern file and then creating a form which contains already the values for 
 * specific elements. The form is then validated and submitted, exactly as the 'submit' button was
 * pressed from the browser window.
 *
 * The following steps (operations) are performed sequentially:
 *
 * * Preparation Phase 
 * -------------------
 *
 *  - 'prepare':      - Transform the patterns tags into the actual element of the form to be submitted. 
 *                    - Add eventual standard values which are missing (this makes writing the pattern
 *                      easier and more synthetic).
 *                    - No errors are raised here.
 *
 *
 * - 'pre-validate':  - Performs standard validation on the 'prepared' tags, and raise errors if any.
 *
 *
 *
 * * Batch Phase
 * -----------------
 *
 * - 'form_id':       - Returns the form_id to call for the specific operation. If an array is returned
 *                      the form_id(s) are called sequentially.
 *                      
 * - 'actions':       - Returns the description of the action performed by the //form_id//. (@TODO: ?? Maybe to integrate in form_id ??)
 * 
 * - 'validate':      - Validate the data for the form_id and raise errors, if any.
 * 
 * - 'build':         - Get the form data for the action. This can either just be the form values, or 
 *                      it can be the full //form_state object//.
 *                      
 * - 'params':        - Get any extra parameters required by the form function.
 * 
 *
 * * Execution Phase      
 * -----------------
 *  drupal_form_submit() is called
 *  
 *  
 * - 'cleanup':       - cleanup operations are performed, if any.
 * 
 *    
 * * Post Batch
 * ---------------   
 *    
 * - 'identifiers':    - ????? Get any primary identifiers from the action for further actions to take advantage of
 *  
 *  
 *  
 * 
 * 
 */

/**
 * @todo:
 * @ Load (some) of the includes only when really needed
 * @ When you modify a pattern you always need to reload the main pattern page, so it noticed that the pattern is actually changed. In confirm form it is too late.
 * @ Enable pattern configurations
 * @ **done**Enable actions to see ids created/updated from other actions inside the pattern (tokens?)
 * @ **semi-done** Reset patterns
 * @ Enable components to analyze the current pattern for better validation
 * @ Allow module version restricting
 * @ Put in functionality to auto-download modules (and the correct version)
 * @ Enable backups before running patterns and reverting back to those backups
 * @ Implement a progress meter
 * @ Handle default values better to allow for absolute minimal actions
 * @ Enable interactive actions by allowing patterns to resume from a saved position
 * @ Implement an export feature for all available form_ids
 * @ Allow resuming failed patterns
 * @ In the pattern details, list any sub-patterns directly on the patterns listing page
 * @ Split this file in includes. **DONE**
 * @ Create a Pattern class (?) check performance
 * @ Increase performaces, it seems still slow.
 * @ Move 'pre-validate' before prepare??
 * @ Check core.php.inc 
 */



/**
 * Implementation of hook_menu().
 */
function patterns_menu() {
  $items = array();

  $items['admin/patterns'] = array(
    'title' => 'Patterns',
    'description' => 'Administer patterns available for your site',
    'page callback' => 'patterns_list',
    'access arguments' => array('administer patterns')
  );
  $items['admin/patterns/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10
  );
  
  // Ste: was
  // $items['admin/patterns/edit'] = array(
  $items['admin/patterns/edit/%'] = array(
    'title' => 'Edit Pattern',
    'page callback' => 'drupal_get_form',
     // Ste: was
     // 'page arguments' => array('patterns_edit'),
    'page arguments' => array('patterns_edit', 4),
    'access arguments' => array('administer patterns'),
    'type' => MENU_CALLBACK
  );
  $items['admin/patterns/enable'] = array(
    'title' => 'Enable Pattern',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('patterns_enable_pattern'),
    'access arguments' => array('administer patterns'),
    'type' => MENU_CALLBACK
  );
  $items['admin/patterns/publish'] = array(
    'title' => 'Publish Pattern',
    'page callback' => 'patterns_publish_pattern',
    'access arguments' => array('administer patterns'),
    'type' => MENU_CALLBACK
  );
  $items['admin/patterns/unpublish'] = array(
    'title' => 'Unpublish Pattern',
    'page callback' => 'patterns_unpublish_pattern',
    'access arguments' => array('administer patterns'),
    'type' => MENU_CALLBACK
  );
  $items['patterns.xml'] = array(
    'title' => 'Published Patterns',
    'page callback' => 'patterns_feed',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK
  );

  $items['admin/patterns/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('patterns_settings'),
    'access arguments' => array('administer patterns'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10
  );

  $items['admin/patterns/get'] = array(
    'title' => 'Download Pattern Source',
    'page callback' => 'patterns_get_source',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK
  );

  //     $items[] = array('path' => 'admin/patterns/configure',
  //       'title' => t('Configure Pattern'),
  //       'callback' => 'drupal_get_form',
  //       'callback arguments' => array('patterns_configure_pattern'),
  //       'type' => MENU_CALLBACK
  //     );

  //     $items[] = array('path' => 'admin/patterns/info',
  //       'title' => t('Pattern Details'),
  //       'callback' => 'patterns_info',
  //       'type' => MENU_CALLBACK
  //     );

  //     $items[] = array('path' => 'admin/patterns/disable',
  //       'access' => user_access('administer patterns'),
  //       'title' => t('Disable Pattern'),
  //       'callback' => 'drupal_get_form',
  //       'callback arguments' => array('patterns_disable_pattern'),
  //       'type' => MENU_CALLBACK
  //     );

  $items['admin/patterns/modules'] = array(
    'title' => 'Pattern Modules',
    'page callback' => 'patterns_modules_page',
    'access arguments' => array('administer patterns'),
    'type' => MENU_CALLBACK
  );

  //     $items[] = array('path' => 'admin/patterns/revert',
  //       'access' => user_access('administer patterns'),
  //       'title' => t('Revert Pattern'),
  //       'callback' => 'patterns_revert',
  //       'type' => MENU_CALLBACK
  //     );


  $items['admin/patterns/import'] = array(
    'title' => 'Import',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('patterns_import_source'),
    'access arguments' => array('administer patterns'),
    'type' => MENU_LOCAL_TASK
  );
  $items['admin/patterns/import/source'] = array(
    'title' => 'Import Source Code',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10
  );
  $items['admin/patterns/import/file'] = array(
    'title' => 'Import File',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('patterns_import_file'),
    'access arguments' => array('administer patterns'),
    'type' => MENU_LOCAL_TASK
  );
  $items['admin/patterns/import/url'] = array(
    'title' => 'Import from URL',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('patterns_import_url'),
    'access arguments' => array('administer patterns'),
    'type' => MENU_LOCAL_TASK
  );
  $items['admin/patterns/server'] = array(
    'title' => 'Patterns Server',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('patterns_import_server'),
    'access arguments' => array('administer patterns'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -5
  );

  return $items;
}




/**
 * First function to be called for displaying the pattern page.
 * 
 */
function patterns_list() {
  
  drupal_add_css(drupal_get_path('module', 'patterns') . '/patterns.css');
  drupal_add_js(drupal_get_path('module', 'patterns') . '/patterns.js');

  // Load the the pattern handlers from compontents directory
  // or from modules which implement hook_patterns
  patterns_load_components();
  
  // Load the patterns from files or from database
  $patterns = patterns_get_patterns();
  
  if (empty($patterns)) {
    return t('No patterns available.');
    
  } 
  
  $header = array(t('Title'), t('Status'), t('Version'), t('Actions'));

  // List all patterns
  $rows = array();
  
  foreach ($patterns as $pid => $pattern) {
    $actions = array();
    
    // Build Run/Re-Run/Update pattern links
    if (!$pattern->status) {
      $actions[] =  l(t('Run'), 'admin/patterns/enable/' . $pid);
    }
    elseif ($pattern->enabled >= $pattern->updated) {
      $actions[] =  l(t('Re-Run'), 'admin/patterns/enable/' . $pid);
    }
    else {
      $actions[] = l(t('Run Update'), 'admin/patterns/enable/' . $pid);
    }
    // Edit Link
    $actions[] = l(t('Edit'), 'admin/patterns/edit/' . $pid);
    
    //Publish/Unpublish link
    if (variable_get('patterns_allow_publish', FALSE)) {
      $actions[] = $pattern->public ? l(t('Unpublish'), 'admin/patterns/unpublish/' . $pid) : l(t('Publish'), 'admin/patterns/publish/' . $pid);
    }
    
    $actions = implode('&nbsp;&nbsp;', $actions);

    
    //      $title = l($pattern->title, 'admin/patterns/info/'. $pid, array('attributes' => array('class' => 'pattern-title', 'id' => 'pid-'. $pid)));
    $title = '<span id="pid-' . $pid . '" class="pattern-title">' . $pattern->title . '</span>';
    //     $view_more = '<div>'. t('Clik on pattern title to see more details.') .'</div>';
    $info = array();
    $info[] = t('Author:') . ' ' . @$pattern->info['author'];
    $info[] = t('Email:') . ' ' . @$pattern->info['author_email'];
    $info[] = t('Web:') . ' ' . @$pattern->info['author_website'];
    $author = theme('item_list', array('items' => $info));
    //    $title .= '<div id="pid-'. $pid .'-info" class="pattern-info">'. $author . $pattern->description . $view_more .'</div>';
    $title .= '<div id="pid-' . $pid . '-info" class="pattern-info">' . $author . $pattern->description . '</div>';
    
    $cells = array();
    $cells[] = array('data' => $title, 'class' => 'title');
    $cells[] = array('data' => $pattern->status ? t('Enabled') : t('Disabled'), 'class' => 'status');
    $cells[] = array('data' => @$pattern->info['version'], 'class' => 'version');
    $cells[] = array('data' => $actions, 'class' => 'actions');
    
    // Group patterns by category
    $category = $pattern->info['category'] ? $pattern->info['category'] : t('Other');
    
    $rows[$category][] = $cells;
  }

  // Builds as many fieldsets as pattern categories
  // and plot tables with the rows we created before
  ksort($rows);
  $output = '';
  foreach ($rows as $title => $category) {
    $fieldset = array('element' => array(
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
      '#children' => t($title), 
      '#value' => theme('table', array('rows' => $category, 'attributes' => array('class' => 'patterns-list'))),
    ));
    $output .= theme('fieldset', $fieldset);
  }

  return $output;
}

/**
 * 
 * Callback function of the path /enable/%
 * It prompts the user with a submenu of options regarding default behavior
 * with sub-patterns.
 * 
 * @TODO: find a way to skip this in pattern_list, to quickly execute the pattern
 * 
 * @param array $form the form array
 * @param array $form_state the state of the array
 * @param mixed $pid
 */
function patterns_enable_pattern($form, &$form_state, $pid) {
  $form['pid'] = array(
    '#type' => 'value',
    '#value' => $pid
  );
  
  $options = array(
    'first-update' => t('only if disabled or if updated since last run (recommended)'),  
    'always' => t('always'),
    'update' => t('only if updated since last run'),
    'first' => t('only if disabled'),
    'never' => t("don't run sub-patterns at all"),
  );
  
  $form['run-subpatterns'] = array(
    '#type' => 'radios',
    '#title' => t('Run sub-patterns:'),
    '#description' => t("Decide when to run sub-patterns that are called by the currently run pattern. If unsure, stick to recommended setting. Note that your choice won't have any effect if your pattern doesn't contain sub-patterns or if this setting has been defined within the pattern file itself."),
    '#options' => $options,
    '#default_value' => 'first-update',
  );
  
  $disclaimer = t('Please be sure to backup your site before running a pattern. Patterns are not guaranteed to be reversable in case they do not execute well or if unforseen side effects occur.');

  $pattern = patterns_get_pattern($pid);

  return confirm_form($form, t('Proceed with running pattern %pattern?', array('%pattern' => $pattern->title)), 'admin/patterns', $disclaimer);
}


/**
 * Takes the values from the form enable_pattern and starts the
 * whole process by calling execute_pattern
 * 
 * @param $form form
 * @param $form_state form_state
 */
function patterns_enable_pattern_submit($form, &$form_state) {
  $pid = $form_state['values']['pid'];

  patterns_load_components();
  $pattern = patterns_get_pattern($pid);

  patterns_start_engine($pattern, $form_state['values']);

  $form_state['redirect'] = 'admin/patterns';
}


/**
 * 
 * The beginning of the whole Patterns logic. Starts the execution in 'batch'
 * mode (default) or 'php' mode, which makes things easier for debugging.
 * 
 * @param stdClass $pattern Pattern object as loaded by patterns_get_pattern()
 * @param array $params Parameters for executing the pattern. Array format as follows:
 * 
 * 
 * pid => Pid of the pattern as it is in the database  
 * run-subpatterns => ['first-update', always','update','first','never']
 * 
 * If coming from form_confirm some other parameters are addes, such as:
 * confirm [1] 
 * submit  [Confirm] 
 * form_build_id 
 * form_token  
 * form_id 
 * op  [Confirm] 
 * 
 * @param mixed $mode ['batch','php'] 
 */
function patterns_start_engine($pattern, $params = array(), $mode = 'batch') {
  
  //require_once 'includes/core.'.$mode.'.inc';
  module_load_include('inc', 'patterns', 'includes/core.' . $mode);
  
  if (!function_exists('patterns_execute_pattern') || !is_object($pattern)) return FALSE;

  return patterns_execute_pattern($pattern, $params);
}


function patterns_rearrange_data($pattern) {
  foreach ($pattern as $key => $value) {
    if (is_string($key)) {
      unset($pattern[$key]);
    }
    else {
      if ($value['tag'] == 'actions') {
        $pattern[$key] = patterns_rearrange_data($value);
        $pattern[$key]['tag'] = 'actions';
      }
      else {
        $pattern[$key] = _patterns_rearrange_data($value);
      }
    }
  }

  return $pattern;
}

/**
 * For use with token replacement
 */
function patterns_array_map($function, $array, $params) {
  $new_array = array();
  foreach( $array as $key => $value ) {
    if (is_array($value)) {
      $new_array[$key] = patterns_array_map($function, $value, $params);
    } else {
      $params[] = $key;
      $key = call_user_func_array($function, $params);
      array_pop($params);
      $params[] = $value;
      $new_array[$key] = call_user_func_array($function, $params);
      array_pop($params);
    }
  }
  return $new_array;
}


/**
 * Return an array with detailed information about the pattern.
 * @TODO improve the doc of patterns_get_pattern_details
 * 
 * @param @param stdClass $pattern Pattern object as loaded by patterns_get_pattern()
 * @param $recursive ??
 * @param $pids ??
 */
function patterns_get_pattern_details($pattern, $recursive = FALSE, &$pids = array()) {

  // prevent infinite recursion
  if (in_array($pattern->pid, $pids)) return array();
  $pids[$pattern->pid] = $pattern->pid;

  $actions = !empty($pattern->pattern['actions']) ? $pattern->pattern['actions'] : array();
  $modules = !empty($pattern->pattern['modules']) ? $pattern->pattern['modules'] : array();

  $patterns[$pattern->pid] = (array)$pattern;
  $patterns[$pattern->pid] = array_merge($patterns[$pattern->pid], $patterns[$pattern->pid]['pattern']['info']);
  unset($patterns[$pattern->pid]['pattern']);

  if ($recursive) {
    $result = array('modules' => $modules, 'info' => $patterns);

    foreach ($actions as $key => $action) {
      if ($action['tag'] == 'pattern') {
        // determine pattern name
        if (!empty($action['value'])) {
          $name = $action['value'];
        }
        elseif (!empty($action['name'])) {
          $name = $action['name'];
        }
        if (!$p = patterns_get_pattern($name)) {
          // just give a warning and try to continue
          drupal_set_message(t('Action #%key in %file: Pattern %pattern not found.<br/>Pattern execution will try to continue without it.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'warning');
          continue;
        }
        
        // Decide if sub-pattern needs to be run based on the mode defined within the pattern or selected in UI at the time of form submission
        // @TODO: UI setting should be able to override a setting defined within the pattern 
        $modes = array('first-update', 'always', 'update', 'first', 'never');
        if (!empty($action['run']) && in_array($action['run'], $modes)) {
          $mode = $action['run'];
        }
        else {
          $mode = $pattern->subpatterns_run_mode;
        }

        switch ($mode) {
          case 'never':
            // don't run sub-pattern 
            drupal_set_message(t('Action #%key in %file: Pattern %pattern not ran because the pattern was set to be skipped.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'status'); 
            continue 2;
            break;
          case 'first':
            // Only run on first run
            if ($p->status) {
              drupal_set_message(t('Action #%key in %file: Pattern %pattern not ran because the pattern was set to execute only on the first run.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'status');
              continue 2;
            }
            break;
          case 'update':
            // Only run on pattern update
            if ($p->enabled >= $p->updated) {
              drupal_set_message(t('Action #%key in %file: Pattern %pattern not ran because the pattern was set to execute only on pattern update.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'status');
              continue 2;
            }
            break;
          case 'first-update':
            // Only run on first run or pattern update
            if ($p->status && $p->enabled >= $p->updated) {
              drupal_set_message(t('Action #%key in %file: Pattern %pattern not ran because the pattern was set to execute only on first run or update.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'status');
              continue 2;
            }
            break;
          case 'always':
          default:
            // Run always
            break;
        }

        $a = patterns_get_pattern_details($p, TRUE, $pids);
        if (is_array($a) && empty($a)) {
          // An empty array is returned on infinite recursion detection
          drupal_set_message(t('Action #%key in %file: Infinite recursion detected while attempting to run pattern %pattern.<br/>Pattern execution will try to continue without it.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'warning');
          continue;
        }
        // array_merge doesn't preserve numeric array keys
        // so we handle 'info' separately
        $info = $result['info'];
        $result = array_merge_recursive($result, $a);
        $result['info'] = $info + $a['info'];
      }
      else {
        $result['actions'][] = $action;
        $result['actions_map'][] = array(
          'pid'   => $pattern->pid,
          'index' => $key,
        );
      }
    }
    $result['modules'] = array_merge(array_unique($result['modules']));
    // Remove pid from recursion stack
    //unset($pids[$pattern->pid]);
    return $result;
  }
  // Remove pid from recursion stack
  //unset($pids[$pattern->pid]);
  return array('actions' => $actions, 'modules' => $modules, 'info' => $patterns);
}


/**
 * Preparing and prevalidating the action tags as they are written 
 * in the pattern file. Concretely, it invokes operations 'prepare', 
 * and 'pre-validate' on the pattern component. 
 * 
 * @param array $actions
 * @param array $actions_map
 * @return array $result array containing the description of eventual errors
 */
function patterns_prepare_actions(&$actions, $actions_map) {

  $result = array('success' => TRUE);

  if (empty($actions)) return $result;

  patterns_load_components();

  // Keep a list of which modules handle what tags
  $tag_modules = patterns_invoke($empty, 'tag modules');

  // TODO Finish basic setup and execution of the 'config' operation
  // TODO Make a better streamlined config framework process. For instance collect form_ids
  // from here and give the form_id and matching data to the 'build' process
  foreach ($actions as $key => &$data) {
    if (($config = patterns_invoke($actions[$key], 'config')) && !empty($config)) {
      patterns_config_data($data, $config);
    }
  }

  $errors = array();
  
  /////////////////////////////////////////////
  // Prepare actions for validation/processing
  /////////////////////////////////////////////
  foreach ($actions as $key => &$data) {
    patterns_invoke($actions[$key], 'prepare');
  }


  //////////////////////////////////////////////////////
  // Pre validate tags with their appropriate components
  //////////////////////////////////////////////////////
  foreach ($actions as $key => &$data) {

    $action_location = patterns_locate_action($key, $actions_map);
    $index = $action_location['key'];
    $pattern_title = $action_location['title'];
//    $pattern_file = $action_location['file'];

    if (!array_key_exists($data['tag'], $tag_modules)) {
      $errors[] = t('Action #%num (%tag) in pattern %title: <%tag> is not a valid tag', array('%num' => $index+1, '%tag' => $data['tag'], '%title' => $pattern_title));
    }
    else {
      $error = patterns_invoke($actions[$key], 'pre-validate');
      if ($error) {
        $errors[] = t('Action #%num (%tag) in pattern %title: !msg', array('!msg' => $error, '%num' => $index+1, '%tag' => $data['tag'], '%title' => $pattern_title));
      }
    }
  }

  if (count($errors)) {
    $message = t('Errors encountered during pre-processing:') . '<br/>' . implode('<br/>', $errors);
    $result['success'] = FALSE;
    $result['error_message'] = $message;
  }

  return $result;
}


/**
 * Execute hook_patterns with the given operation and return the 
 * results. 
 * 
 * It also builds up, if necessary, the list of 
 * available action-tags and binds them to the correct module.
 * 
 * @param array $data the 
 * @param mixed $op operation to be performed by hook_patterns()
 * @param mixed $form_id name of the form to be passed to hook_patterns().
 * @param array $a extra parameters to pass to hook_patterns()
 */
function patterns_invoke(&$data, $op, $form_id = NULL, &$a = NULL) {
  static $tag_modules;

  if (!is_array($tag_modules) || $op == 'tag modules') {
    // Get a list of tags and their modules
    foreach (module_implements('patterns') as $module) {
      $tags = module_invoke($module, 'patterns', 'tags');

      foreach ($tags as $tag => $value) {
        if (is_array($value)) {
          $tag_modules[$tag] = $module;
        }
        else {
          $tag_modules[$value] = $module;
        }
      }
    }
  }

  // If you just want the modules list
  if ($op == 'tag modules') {
    return $tag_modules;
  }

  $tag = $data['tag'];
  unset($data['tag']);

  $module = $tag_modules[$tag];
  $func = $module . '_patterns';

  if (function_exists($func)) {
    if ($form_id) {
      $return = $func($op, $form_id, $data, $a);
    }
    else {
      $return = $func($op, $tag, $data, $a);
    }
  }

  $data['tag'] = $tag;
  return $return;
}

function _patterns_rearrange_data($data, $parent = '') {
  $numeric = array();
  $count = 0;

  foreach ($data as $key => $value) {
    if (isset($value['value'])) {
      if ($value['value'] == 'false') {
        $value['value'] = FALSE;
      }
      elseif ($value['value'] == 'true') {
        $value['value'] = TRUE;
      }
    }

    if (is_numeric($key) && is_array($value) && count($value) == 2 && isset($value['tag']) && isset($value['value'])) {
      unset($data[$key]);
      if (isset($data[$value['tag']])) {
        $numeric[] = $value['tag'];
        $data[$count++] = $data[$value['tag']];
        $data[$count++] = $value['value'];
        unset($data[$value['tag']]);
      }
      elseif (in_array($value['tag'], $numeric)) {
        $data[$count++] = $value['value'];
      }
      else {
        $data[$value['tag']] = $value['value'];
      }
    }
    elseif (is_numeric($key)) {
      $tag = $value['tag'];
      unset($value['tag']);
      $data[$tag][] = _patterns_rearrange_data($value, $tag);
      unset($data[$key]);
    }
  }

  foreach ($data as $key => $value) {
    if (is_array($value) && count($value) == 1 && $value[0]) {
      $data[$key] = $data[$key][0];
    }
  }

  // This workaround enables us to define numeric keys in XML by
  // prefixing the number with single character. E.g <n0>value</n0>
  // will result in 0 => 'value' (first character of the key will be removed).
  if (isset($data['_numeric_keys'])) {
    unset($data['_numeric_keys']);
    foreach ($data as $key => $value) {
      $data[substr($key, 1)] = $value;
      unset($data[$key]);
    }
  }

  return $data;
}


function patterns_form_alter(&$form, &$form_state, $form_id) {

  if (user_access('administer patterns') && variable_get('patterns_form_helper', FALSE)) {
    $form['#after_build'][] = 'patterns_form_helper';
  }

  if (patterns_executing()) {
    // Ensure that parent and related dropdowns display all the terms
    // including those created during current pattern execution.
    // Without this, those terms would be omitted due to the static
    // caching within taxonomy_get_tree().
    $form_ids = array('taxonomy_form_term');
    if (in_array($form_id, $form_ids)) {
      $tid = $form['#term']['tid'];
      $vid = $form['#vocabulary']['vid'];
      $parent = array_keys(taxonomy_get_parents($tid));

      $children = _patterns_taxonomy_get_tree($vid, $tid);
      // A term can't be the child of itself, nor of its children.
      foreach ($children as $child) {
        $exclude[] = $child->tid;
      }
      $exclude[] = $tid;

      $form['advanced']['parent'] = _patterns_taxonomy_term_select(t('Parents'), 'parent', $parent, $vid, t('Parent terms') . '.', 1, '<' . t('root') . '>', $exclude);
      $form['advanced']['relations'] = _patterns_taxonomy_term_select(t('Related terms'), 'relations', array_keys(taxonomy_get_related($tid)), $vid, NULL, 1, '<' . t('none') . '>', array($tid));
    }

    // Ensure that parent item dropdown displays all the menu items
    // including those created during current pattern execution.
    // Without this, those menu items would be omitted due to the
    // static caching within menu_tree_all_data().
    $form_ids = array('menu_edit_item');
    if (in_array($form_id, $form_ids)) {
      if (empty($form['menu']['#item'])) {
        $item = array('link_title' => '', 'mlid' => 0, 'plid' => 0, 'menu_name' => $form_state['values']['menu']['menu_name'], 'weight' => 0, 'link_path' => '', 'options' => array(), 'module' => 'menu', 'expanded' => 0, 'hidden' => 0, 'has_children' => 0);
      }
      else {
        $item = $form['menu']['#item'];
      }
      $form['menu']['parent']['#options'] = _patterns_menu_parent_options(menu_get_menus(), $item);
    }

    // Ensure that taxonomy dropdowns on node edit form display all the terms
    // including those created during current pattern execution.
    if (!empty($form['taxonomy']) && isset($form['type']) && isset($form['#node']) && $form['type']['#value'] . '_node_form' == $form_id) {
      foreach ($form['taxonomy'] as $vid => $v) {
        if (!is_numeric($vid)) continue;
        $form['taxonomy'][$vid] = _patterns_taxonomy_form($vid, $form['taxonomy'][$vid]['#default_value'], $form['taxonomy'][$vid]['#description']);
      }
    }
  }

}


function patterns_exit($destination = NULL) {
  $batch =& batch_get();
  if (variable_get('patterns_form_helper', FALSE) && $_SESSION['patterns_form_helper'] && !$destination && empty($batch)) {
    if (module_exists('devel')) {
      //dpm($_SESSION['patterns_form_helper']);
      kprint_r($_SESSION['patterns_form_helper']);
    }
    else {
      print theme('patterns_form_helper', $_SESSION['patterns_form_helper']['form_id'], $_SESSION['patterns_form_helper']['form_values']);
    }

  }
}


/**
 * Function callback
 */
function _patterns_modify_value(&$form) {
  foreach ($form as $key => $value) {
    if (is_array($value) && isset($value['#type']) && $value['#type'] == 'value') {
      $form[$key]['#default_value'] = $value['#value'];
      unset($form[$key]['#value']);
    }
    elseif (is_array($value)) {
      _patterns_modify_value($form[$key]);
    }
  }
}

/**
 * Recurse an array and replace with tokens
 * @ This is used instead of array_walk_recursive because
 *   of some strange issues with token_get_values failing.
 */
function _patterns_recurse_tokens(&$object, $identifiers) {
  foreach ($object as $key => $value) {
    if (is_array($value)) {
      _patterns_recurse_tokens($object[$key], $identifiers);
    }
    elseif (is_scalar($value)) {
      $old_key = $key;
      _patterns_replace_tokens($object[$key], $key, $identifiers);

      // The key was changed, change it
      if ($old_key != $key) {
        $keys = array_keys($object);
        $keys[array_search($old_key, $keys)] = $key;
        $object = array_combine($keys, array_values($object));
      }
    }
  }
}

/**
 * Array walk callback to replace tokens inside form values
 */
function _patterns_replace_tokens(&$a, &$b, $identifiers = array()) {
  static $count = 0;

  // Replace IDs with identifiers from the current executing pattern
  if (preg_match('/@([a-zA-Z0-9_]+)@/', $a, $match)) {
    $a = str_replace($match[0], $identifiers[$match[1]], $a);
  }
  if (preg_match('/__([a-zA-Z0-9_]+)__/', $b, $match)) {
    $b = str_replace($match[0], $identifiers[$match[1]], $a);
  }

  // Replace tokens
  // Ste: was
  //$a = token_replace($a, 'global', NULL, '@', '@');
  //$b = token_replace($b, 'global', NULL, '__', '__');\
  
  //$a = token_replace($a, 'global', NULL, '@', '@');
  //$b = token_replace($b, 'global', NULL, '__', '__');
  
  
}



function theme_patterns_form_helper_menu($forms) {
  $output = '<ul class="patterns-form-menu">';

  foreach ($forms as $form_id => $values) {
    $output .= '<li class="patterns-form-menu-item">' . $form_id . '</li>';
  }

  $output .= '</li>';

  return $output;
}

function theme_patterns_form_helper($form_id, $values) {

  $output = '<div class="patterns-form" id="patterns-form-' . $form_id . '">';

  $output .= '<div class="patterns-form-title">' . t('Form values for %key', array('%key' => $form_id)) . '</div>';

  foreach ($values as $key => $value) {
    $output .= '<div class="patterns-form-item"><div class="patterns-form-key">' . $key . ' => </div>';
    $output .= '<div class="patterns-form-value">' . print_r($value, TRUE) . '</div></div>';
  }

  $output .= '</div>';

  return $output;
}

/**
 * Implementation of hook_theme().
 */
function patterns_theme() {
  return array(
    'patterns_form_helper' => array(
      'arguments' => array('form_id' => NULL, 'values' => NULL),
  ),
    'patterns_form_helper_menu' => array(
      'forms' => NULL
  )
  );
}

/**
 * Make some modifications to the form values based on the form
 * In particular, make sure form elements with #options and #multiple
 * set the keys of the array as the key of the value as how FAPI does it,
 * but XML of course does not.
 */
function patterns_sync_form_values($args) {
  $form_id = $args[0];
  
  // this functionality is not working well with 
  // node forms (create/update node)
  // so skip them until this issue is fixed 
  if (strpos($form_id, 'node_form') !== FALSE) {
    return;
  }
    
  // References inside the form_state can cause potential problems,
  // so we'll ensure no references to outside data exists
  $form_state = unserialize(serialize($args[1]));
  $form_values = $form_state['values'];
  unset($args[1]['values']);

  // Get the fully built fapi object with cloned form_state.
  // We need to do this with a separate form_state because
  // this can mess up the form values if they are setup incorrectly
  // (it'll get fixed here)
  $form = call_user_func_array('drupal_retrieve_form', $args);
  drupal_prepare_form($form_id, $form, $form_state);
  $form = form_builder($form_id, $form, $form_state);

  // Loop through all form values looking for #options
  $queue = array(&$form);

  while (!empty($queue)) {
    $check = &$queue[0];
    array_shift($queue);

    // Skip disabled items
    if ($check['#disabled']) {
      continue;
    }

    // Set default values for everything that the form is expecting values for.
    // This can save work in the components as well as avoid bugs when a module
    // expects values to be there that are not.
    // Do not set default values when it is the type of value that a form submit
    // would not set data in $_POST for. Like selects with no options or unchecked
    // checkboxes
    if ($check['#input'] && isset($check['#default_value']) &&
        !($check['#type'] == 'select' && empty($check['#options'])) &&
        !(in_array($check['#type'], array('checkbox', 'checkboxes')) && empty($check['#default_value']))) {
      $match = &$form_values;
      $found = TRUE;
      foreach ($check['#parents'] as $path) {
        if (!isset($match[$path])) {
          $found = FALSE;
          $match[$path] = array();
        }
        // If this is not an array, the data was probably not completed properly
        // in the pattern.
        if (!is_array($match)) {
          $message = t('Invalid pattern syntax at: !path. Expecting more child elements.', array('!path' => implode('->', $check['#parents'])));
          patterns_error_handler(1, $message, '', '');
          return;
        }
        $match = &$match[$path];
      }

      // Set the default value unless it is a type of value that would originally
      // not be set in $_POST during form submit, like empty selects
      if (!$found) {
        $check['#missing_in_pattern'] = TRUE;
        $match = $check['#default_value'];
      }
    }

    if (!empty($check['#options'])) {
      $scalar = FALSE;
      if ((!$check['#tree'] && !$check['#multiple']) || (isset($check['#multiple']) && !$check['#multiple']) || in_array($check['#type'], array('radio', 'radios'))) {
        $scalar = TRUE;
      }

      // Find possible corresponding data in form values
      $match = &$form_values;
      $found = TRUE;
      foreach ($check['#parents'] as $path) {
        if (isset($match[$path])) {
          $match = &$match[$path];
        }
        else {
          $found = FALSE;
          break;
        }
      }

      if ($found && isset($match)) {
        // Check if we are overwriting or not.
        //
        // First, if the pattern value is there, but empty, we obviously
        // should be overwriting. Next is to check if overwrite was specified
        // manually
        $overwrite = FALSE;
        if (!$check['#missing_in_pattern'] && (empty($match) || (is_array($match) && !empty($match['overwrite'])))) {
          $overwrite = TRUE;
          if (is_array($match) && isset($match['overwrite'])) {
            unset($match['overwrite']);
          }
        }

        $delete = FALSE;
        if (is_array($match) && !empty($match['delete'])) {
          $delete = TRUE;
          unset($match['delete']);
        }
        
        // If overwriting, start the values array with all the
        // possible values but empty. We will possibly fill them
        // in with default values on update actions. Select types
        // do not work when empty, non-selected, values are set
        if (!$scalar && $overwrite && $check['#type'] != 'select') {
          $values = $check['#options'];
          foreach ($values as &$v) {
            $v = '';
          }
        }
        else {
          $values = array();
        }

        if (!$overwrite && !empty($check['#default_value'])) {
          foreach ((array)$check['#default_value'] as $value) {
            $values[$value] = $value;
          }

          // Make sure we are still restricted to values available in #options
          $values = array_intersect_key($values, $check['#options']);
        }

        // Flatten out the options in case it is trying to use optgroups
        $options = patterns_options_flatten($check['#options']);

        foreach ((array)$match as $value) {
          $key = array_search($value, $options);

          // If the supplied value is an actual options value (not the label) use that
          if ((is_string($value) || is_int($value)) && array_key_exists($value, $options)) {
            $values[$value] = $delete ? 0 : $value;
          }
          // Or if the supplied value matches an options label, use that option
          elseif ($key !== FALSE) {
            $values[$key] = $delete ? 0 : $key;
          }
          // If we are trying to set an invalid value, at least select
          // the first value for select forms since it is impossible to
          // not select a good value there
          elseif ($check['#type'] == 'select') {
            reset($options);
            $values[key($options)] = key($options);
          }
        }

        // If we are not on a multiple/tree form, the value should be singular/not an array.
        // We make sure to use the last value here because the last value will absolutely
        // be the user/pattern supplied value as opposed to the default_value
        if ($scalar) {
          $match = end($values);
        }
        else {
          $match = $values;
        }
      }
    }

    foreach (element_children($check) as $element) {
      $queue[] = &$check[$element];
    }
  }

  // Make sure the new form_values will be used in the real executions
  $args[1]['values'] = $form_values;
}

/**
 * Take a $data and $config object and adjust $data
 * based on the supplied configuration
 *
 * TODO Look for ways to optimize and increase performance
 */
function patterns_config_data(&$data, $configs) {
  foreach ($configs as $path => $config) {
    // An alias key requires multiple paths
    // for each alias and then a #real set
    // to change all of them to the same key
    // TODO test #alias
    if ($config['#alias'] && is_array($config['#alias'])) {
      $tokens = array_slice(preg_split('/(?<!=)\/(?![a-z]*\])/', $path), 1);
      $real = end($tokens);

      // Check for the real key
      $matches = patterns_array_fetch($path, $data);

      // If the real key was not found, get the aliases
      if (empty($matches)) {
        if (!$config['#key']) {
          $config['#key'] = $real;
        }
        foreach ($config['#alias'] as $alias) {
          $tokens[count($tokens)-1] = $alias;
          $matches += patterns_array_fetch('/' . implode('/', $tokens), $data);
        }
      }
    }
    else {
      $matches = patterns_array_fetch($path, $data);
    }

    // If no matches were found and it is a required element
    // return an error
    if (empty($matches) && $config['#required']) {
      $error = TRUE;
    }

    foreach ($matches as &$match) {
      // Collect form_ids here.
      // TODO Think of a better way to migrate components form_id operations here
      if ($config['#form_id']) {
        patterns_config_form_ids($data['tag'], $config['#form_id'], $match);
      }

      // Make sure values that should be arrays are set as such
      if ($config['#array'] && !array_key_exists(0, $match['item'])) {
        if (is_null($match['item']) || (is_array($match['item'] && empty($match['item'])))) {
          $match['item'] = array();
        }
        else {
          $match['item'] = array($match['item']);
        }

        // Update the context object to reflect new changes
        $match = _patterns_array_context($match['item'], $match);
      }

      // Change the key of this match. Can get the key value via xpath as well.
      // Any duplicate keys will return an error
      if ($config['#key']) {
        // Check that a single match is found via this xpath and that the resulting value is scalar
        if ($config['#key']{0} == '/' && ($sub_matches = patterns_array_fetch($config['#key'], $match['item'], $match)) && count($sub_matches) == 1 && is_scalar($sub_matches[0]['item'])) {
          // an xpath from the matched item is used to get the key value
          $new_key = $sub_matches[0]['item'];
        }
        elseif ($config['#default key']) {
          $new_key = $config['#default key'];
        }
        elseif ($config['#key']{0} == '/') {
          // Could not find the appropriate key value from the xpath
          $error = TRUE;
        }
        else {
          // Set the key to a static value. Typically used for allowing more user readable keys
          $new_key = $config['#key'];
        }

        if ($new_key && array_key_exists($new_key, $match['parent']['item'])) {
          // The new key already exists.
          $error = TRUE;
        }
        elseif ($new_key) {
          $key = $match['key'];
          $match['parent']['item'][$new_key] = $match['item'];
          // TODO This is buggy. Skip for now.
          if (is_int($key) && FALSE) {
            array_splice($match['parent']['item'], $key, 1);
          }
          else {
            unset($match['parent']['item'][$key]);
          }

          // Update the parent context object to reflect new changes
          $match['parent'] = _patterns_array_context($match['parent']['item'], $match['parent']);

          // Update to the new current match
          for ($i=0, $total = count($match['parent']); $i < $total; $i++) {
            if ($match['parent'][$i]['key'] == $new_key) {
              $match = &$match['parent'][$i];
              break;
            }
          }
        }
      }

      // Create empty key elements if they don't exist but should (and are not required)
      // This is useful when using 'move' to ensure that the destination exists
      if ($config['#create'] && is_array($match['item']) && !array_key_exists($config['#create'], $match['item'])) {
        $match['item'][$config['#create']] = $config['#create value'];
      }

      // Move(or copy) this match to somewhere else in the object. If more than one destination
      // match is found, this value is copied to each one
      // TODO Make move automatically create the destination if it doesn't exist
      // TODO Support move in (put inside array) and move to (replace) actions
      if (!empty($match['parent']) && ($config['#move']{0} == '/' && ($dest_path = $config['#move']) && ($op = 'move')) ||
      ($config['#copy']{0} == '/' && ($dest_path = $config['#copy']) && ($op = 'copy'))) {
        $dests = patterns_array_fetch($dest_path, $match['item'], $match);
        $parent = &$match['parent'];
        $obj = $match['item'];

        foreach ($dests as $dest) {
          // Can't move to items that are not an array
          if (!is_array($dest['item'])) {
            continue;
          }
          if (!is_int($match['key'])) {
            $dest['item'][$match['key']] = $obj;
          }
          else {
            $dest['item'][] = $obj;
          }

          // Update the dest object to reflect the change
          $dest = _patterns_array_context($dest['item'], $dest);
        }

        if ($op == 'move') {
          if (!is_int($match['key'])) {
            unset($parent['item'][$match['key']]);
          }
          else {
            array_splice($parent['item'], $match['key'], 1);
          }

          // Update the parent object to reflect the change (removal)
          $parent = _patterns_array_context($parent['item'], $parent);
          unset($match);
        }
      }
    }
  }
}


function patterns_set_error_handler() {
  // set custom error handler
  set_error_handler('patterns_error_handler');
  // trigger dummy error
  // this will be used as a refrence to determine if any real error
  // occured during the pattern execution
  @trigger_error('patterns_error');
}

function patterns_restore_error_handler() {
  restore_error_handler();
}

/**
 * Custom error handler used only during patterns execution
 * in order to catch and properly handle PHP errors.
 * Based on drupal_error_handler().
 */
function patterns_error_handler($errno, $message, $filename, $line, $context) {

  if ($errno & (E_ALL ^ E_NOTICE)) {

    $types = array(1 => 'error', 2 => 'warning', 4 => 'parse error', 8 => 'notice', 16 => 'core error', 32 => 'core warning', 64 => 'compile error', 128 => 'compile warning', 256 => 'user error', 512 => 'user warning', 1024 => 'user notice', 2048 => 'strict warning', 4096 => 'recoverable fatal error');

    // For database errors, we want the line number/file name of the place that
    // the query was originally called, not _db_query().
    if (isset($context['DB_ERROR'])) {
      $backtrace = array_reverse(debug_backtrace());

      // List of functions where SQL queries can originate.
      $query_functions = array('db_query', 'pager_query', 'db_query_range', 'db_query_temporary', 'update_sql');

      // Determine where query function was called, and adjust line/file
      // accordingly.
      foreach ($backtrace as $index => $function) {
        if (in_array($function['function'], $query_functions)) {
          $line = $backtrace[$index]['line'];
          $filename = $backtrace[$index]['file'];
          break;
        }
      }
    }

    // 'patterns_error' is not a real error and should be skipped
    if ($message != 'patterns_error') {
      watchdog('php', '%message in %file on line %line.', array('%error' => $types[$errno], '%message' => $message, '%file' => $filename, '%line' => $line), WATCHDOG_ERROR);
      patterns_error_set_last(array('message' => $message, 'type' => $errno, 'file' => $filename, 'line' => $line));
    }
  }
  return TRUE;
}

function patterns_error_set_last($error = NULL) {
  static $last_error = array();

  if (isset($error)) {
    $last_error = $error;
  }
  return $last_error;
}

/**
 * Check and report PHP errors during patterns execution
 *
 * @param $op
 *   operation within hook_patterns() during which error occured
 * @param $key
 *   number of the action currently proccessed
 * @param $description
 *   description of the current action
 * @param $pattern_title
 *   title of the pattern currently proccessed
 * @param $pattern_file
 *   path to pattern file currently proccessed
 * @return
 *   error message if new error encountered
 *   FALSE if there are no new errors
 *
 */
function patterns_error_get_last($op, $key, $description, $pattern_title, $pattern_file) {
  $error = patterns_error_set_last();

  if (!empty($error) && $error['message'] != 'patterns_error') {
    $types = array(1 => 'error', 2 => 'warning', 4 => 'parse error', 8 => 'notice', 16 => 'core error', 32 => 'core warning', 64 => 'compile error', 128 => 'compile warning', 256 => 'user error', 512 => 'user warning', 1024 => 'user notice', 2048 => 'strict warning', 4096 => 'recoverable fatal error');
    $php_error_message = $types[$error['type']] . ': ' . $error['message'] . ' in ' . $error['file'] . ' on line ' . $error['line'] . '.';
    $message = t('Pattern %title (%pattern_file)<br/>Action #%key: %description (op "%op")<br/>PHP error occured:<br/>%error', array('%key' => $key, '%title' => $pattern_title, '%op' => $op, '%description' => $description, '%error' => $php_error_message, '%pattern_file' => $pattern_file));
    return $message;
  }
  return FALSE;
}

/**
 * Custom implementation of drupal_process_form()
 *
 * Enables validation to be performed for each executed form
 * by calling our custom _patterns_validate_form() function
 * see issue: http://drupal.org/node/260934
 */
function _patterns_process_form($form_id, &$form, &$form_state) {
  //$form_state['values'] = array(); // ????

  $form = form_builder($form_id, $form, $form_state);

  // Only process the form if it is programmed or the form_id coming
  // from the POST data is set and matches the current form_id.
  //Ste: was
  //if ((!empty($form['#programmed'])) || (!empty($form['#post']) && (isset($form['#post']['form_id']) && ($form['#post']['form_id'] == $form_id)))) {
  if (TRUE) {
    _patterns_validate_form($form_id, $form, $form_state);

    // form_clean_id() maintains a cache of element IDs it has seen,
    // so it can prevent duplicates. We want to be sure we reset that
    // cache when a form is processed, so scenerios that result in
    // the form being built behind the scenes and again for the
    // browser don't increment all the element IDs needlessly.
    // Ste: was
    //form_clean_id(NULL, TRUE);
    drupal_clean_css_identifier(NULL);
    
    //Ste: was
    //if ((!empty($form_state['submitted'])) && !form_get_errors() && empty($form_state['rebuild'])) {
    if (TRUE) { 
      $form_state['redirect'] = NULL;
      form_execute_handlers('submit', $form, $form_state);

      // We'll clear out the cached copies of the form and its stored data
      // here, as we've finished with them. The in-memory copies are still
      // here, though.
      if (variable_get('cache', CACHE_DISABLED) == CACHE_DISABLED && !empty($form_state['values']['form_build_id'])) {
        cache_clear_all('form_' . $form_state['values']['form_build_id'], 'cache_form');
        cache_clear_all('storage_' . $form_state['values']['form_build_id'], 'cache_form');
      }

      // If batches were set in the submit handlers, we process them now,
      // possibly ending execution. We make sure we do not react to the batch
      // that is already being processed (if a batch operation performs a
      // drupal_execute).
      if ($batch =& batch_get() && !isset($batch['current_set'])) {
        // The batch uses its own copies of $form and $form_state for
        // late execution of submit handers and post-batch redirection.
        $batch['form'] = $form;
        $batch['form_state'] = $form_state;
        $batch['progressive'] = !$form['#programmed'];
        batch_process();
        // Execution continues only for programmatic forms.
        // For 'regular' forms, we get redirected to the batch processing
        // page. Form redirection will be handled in _batch_finished(),
        // after the batch is processed.
      }

      // If no submit handlers have populated the $form_state['storage']
      // bundle, and the $form_state['rebuild'] flag has not been set,
      // we're finished and should redirect to a new destination page
      // if one has been set (and a fresh, unpopulated copy of the form
      // if one hasn't). If the form was called by drupal_execute(),
      // however, we'll skip this and let the calling function examine
      // the resulting $form_state bundle itself.
      if (!$form['#programmed'] && empty($form_state['rebuild']) && empty($form_state['storage'])) {
        drupal_redirect_form($form, $form_state['redirect']);
      }
    }
  }
}

/**
 * Custom implementation of drupal_validate_form()
 *
 * Removed static variable that prevented same form_id to be
 * validated more then once during a single page request
 */
function _patterns_validate_form($form_id, $form, &$form_state) {
  // If the session token was set by drupal_prepare_form(), ensure that it
  // matches the current user's session.
  if (isset($form['#token'])) {
    if (!drupal_valid_token($form_state['values']['form_token'], $form['#token'])) {
      // Setting this error will cause the form to fail validation.
      form_set_error('form_token', t('Validation error, please try again. If this error persists, please contact the site administrator.'));
    }
  }

  _form_validate($form, $form_state, $form_id);
}

/**
 * Custom implementation of Drupal's _taxonomy_term_select()
 *
 * Used to override static caching in taxonmy_get_tree()
 * which is preventing terms added during patterns execution
 * to be included in parents and relations dropdowns and
 * causes validation errors.
 * Hopefully, we can find better solution for this.
 */
function _patterns_taxonomy_term_select($title, $name, $value, $vocabulary_id, $description, $multiple, $blank, $exclude = array()) {
  $tree = _patterns_taxonomy_get_tree($vocabulary_id);

  $options = array();

  if ($blank) {
    $options[''] = $blank;
  }
  if ($tree) {
    foreach ($tree as $term) {
      if (!in_array($term->tid, $exclude)) {
        $choice = new stdClass();
        $choice->option = array($term->tid => str_repeat('-', $term->depth) . $term->name);
        $options[] = $choice;
      }
    }
  }

  return array('#type' => 'select',
    '#title' => $title,
    '#default_value' => $value,
    '#options' => $options,
    '#description' => $description,
    '#multiple' => $multiple,
    '#size' => $multiple ? min(9, count($options)) : 0,
    '#weight' => -15,
    '#theme' => 'taxonomy_term_select',
  );
}

/**
 * Custom implementation of Drupal's taxonomy_get_tree()
 *
 * Removed static caching.
 * New terms may be created during patterns execution and
 * static caching prevents them from being returned in
 * all subsequent calls to taxonomy_get_tree() during
 * the current pattern execution (within current page request)
 */
function _patterns_taxonomy_get_tree($vid, $parent = 0, $depth = -1, $max_depth = NULL) {

  $depth++;

  $children[$vid] = array();

  // Ste: was
  //$result = db_query(db_rewrite_sql('SELECT t.tid, t.*, parent FROM {term_data} t INNER JOIN {term_hierarchy} h ON t.tid = h.tid WHERE t.vid = %d ORDER BY weight, name', 't', 'tid'), $vid);
  $result = db_query(db_rewrite_sql('SELECT t.tid, t.*, parent FROM {taxonomy_term_data} t INNER JOIN {taxonomy_term_hierarchy} h ON t.tid = h.tid WHERE t.vid = :vid ORDER BY weight, name', 't', 'tid'), array('vid' => $vid));

  //Ste: was
  //while ($term = db_fetch_object($result)) {
  foreach ($result as $term) {
    $children[$vid][$term->parent][] = $term->tid;
    $parents[$vid][$term->tid][] = $term->parent;
    $terms[$vid][$term->tid] = $term;
  }

  $max_depth = (is_null($max_depth)) ? count($children[$vid]) : $max_depth;
  $tree = array();
  if (!empty($children[$vid][$parent])) {
    foreach ($children[$vid][$parent] as $child) {
      if ($max_depth > $depth) {
        $term = clone $terms[$vid][$child];
        $term->depth = $depth;
        // The "parent" attribute is not useful, as it would show one parent only.
        unset($term->parent);
        $term->parents = $parents[$vid][$child];
        $tree[] = $term;

        if (!empty($children[$vid][$child])) {
          $tree = array_merge($tree, _patterns_taxonomy_get_tree($vid, $child, $depth, $max_depth));
        }
      }
    }
  }

  return $tree;
}

/**
 * Custom implementation of Drupal's taxonomy_form()
 *
 * Used to override static caching for taxonomy terms on node edit form.
 */
function _patterns_taxonomy_form($vid, $value = 0, $help = NULL, $name = 'taxonomy') {
  $vocabulary = taxonomy_vocabulary_load($vid);
  $help = ($help) ? $help : $vocabulary->help;

  if (!$vocabulary->multiple) {
    $blank = ($vocabulary->required) ? t('- Please choose -') : t('- None selected -');
  }
  else {
    $blank = ($vocabulary->required) ? 0 : t('- None -');
  }

  return _patterns_taxonomy_term_select(check_plain($vocabulary->name), $name, $value, $vid, $help, intval($vocabulary->multiple), $blank);
}

/**
 * Custom implementation of Drupal's menu_parent_options()
 *
 * Used to override static caching in menu_tree_all_data()
 * which is preventing menu items created during patterns execution
 * to be included in 'parent item' dropdown and causes validation errors.
 * Hopefully, we can find better solution for this.
 */
function _patterns_menu_parent_options($menus, $item) {
  // The menu_links table can be practically any size and we need a way to
  // allow contrib modules to provide more scalable pattern choosers.
  // hook_form_alter is too late in itself because all the possible parents are
  // retrieved here, unless menu_override_parent_selector is set to TRUE.
  if (variable_get('menu_override_parent_selector', FALSE)) {
    return array();
  }
  // If the item has children, there is an added limit to the depth of valid parents.
  if (isset($item['parent_depth_limit'])) {
    $limit = $item['parent_depth_limit'];
  }
  else {
    $limit = _menu_parent_depth_limit($item);
  }

  foreach ($menus as $menu_name => $title) {
    $tree = _patterns_menu_tree_all_data($menu_name, NULL);
    $options[$menu_name . ':0'] = '<' . $title . '>';
    _menu_parents_recurse($tree, $menu_name, '--', $options, $item['mlid'], $limit);
  }
  return $options;
}

/**
 * Custom implementation of Drupal's menu_tree_all_data()
 *
 * Removed static caching.
 * New menu items may be created during pattern execution and
 * static caching prevents them from being returned in
 * all subsequent calls to menu_tree_all_data() during
 * the current pattern execution (within current page request)
 */
function _patterns_menu_tree_all_data($menu_name = 'navigation', $item = NULL) {
  $tree = array();

  // Use $mlid as a flag for whether the data being loaded is for the whole tree.
  $mlid = isset($item['mlid']) ? $item['mlid'] : 0;
  // Generate a cache ID (cid) specific for this $menu_name and $item.
  $cid = 'links:' . $menu_name . ':all-cid:' . $mlid;

  // If the static variable doesn't have the data, check {cache_menu}.
  $cache = cache_get($cid, 'cache_menu');
  if ($cache && isset($cache->data)) {
    // If the cache entry exists, it will just be the cid for the actual data.
    // This avoids duplication of large amounts of data.
    $cache = cache_get($cache->data, 'cache_menu');
    if ($cache && isset($cache->data)) {
      $data = $cache->data;
    }
  }
  // If the tree data was not in the cache, $data will be NULL.
  if (!isset($data)) {
    // Build and run the query, and build the tree.
    if ($mlid) {
      // The tree is for a single item, so we need to match the values in its
      // p columns and 0 (the top level) with the plid values of other links.
      $args = array(0);
      for ($i = 1; $i < MENU_MAX_DEPTH; $i++) {
        $args[] = $item["p$i"];
      }
      $args = array_unique($args);
      $placeholders = implode(', ', array_fill(0, count($args), '%d'));
      $where = ' AND ml.plid IN (' . $placeholders . ')';
      $parents = $args;
      $parents[] = $item['mlid'];
    }
    else {
      // Get all links in this menu.
      $where = '';
      $args = array();
      $parents = array();
    }
    array_unshift($args, $menu_name);
    // Select the links from the table, and recursively build the tree.  We
    // LEFT JOIN since there is no match in {menu_router} for an external
    // link.
    
    // Ste: was    
//    $data['tree'] = menu_tree_data(db_query("
//      SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*
//      FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path
//      WHERE ml.menu_name = '%s'". $where ."
//      ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC", $args), $parents);
    
      $data['tree'] = menu_tree_data(db_query("
      SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*
      FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path
      WHERE ml.menu_name = :args" . $where . "
      ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC", array('args' => $args)), $parents);
       
    
    $data['node_links'] = array();
    menu_tree_collect_node_links($data['tree'], $data['node_links']);
    // Cache the data, if it is not already in the cache.
    $tree_cid = _menu_tree_cid($menu_name, $data);
    if (!cache_get($tree_cid, 'cache_menu')) {
      cache_set($tree_cid, $data, 'cache_menu');
    }
    // Cache the cid of the (shared) data using the menu and item-specific cid.
    cache_set($cid, $tree_cid, 'cache_menu');
  }
  // Check access for the current user to each item in the tree.
  menu_tree_check_access($data['tree'], $data['node_links']);
  $tree[$cid] = $data['tree'];

  return $tree[$cid];
}




function patterns_debug_batch($var = NULL) {
  $var = print_r($var, TRUE);
  $var = str_replace(" ", '&nbsp;', $var);
  $var = str_replace("\n", "<br />", $var);
  print drupal_to_js(array('status' => 0, 'data' => $var));
  exit;
}


// function patterns_revert($pid) {
//   if ($name = db_result(db_query('SELECT name FROM {patterns} WHERE pid = "%d"', $pid))) {
//     $path = file_create_path(variable_get('patterns_save_xml', 'patterns') .'/enabled/'. $name .'.xml');
//     $new = db_result(db_query('SELECT file FROM {patterns} WHERE pid = "%d"'));
//   }
//   else {
//     drupal_set_message(t('The pattern you specified does not exist.'), 'error');
//     drupal_goto('admin/patterns');
//   }
//
//   if (file_exists($path)) {
//     if (file_move($path, $new, FILE_EXISTS_REPLACE)) {
//       drupal_set_message(t('This pattern was reverted to the state it was at when it was enabled.'));
//       drupal_goto();
//     }
//   }
//   else {
//     drupal_set_message(t('The patterns enabled-state was not saved properly, therefore it cannot be reverted.'), 'error');
//   }
//
//   drupal_goto('admin/patterns');
// }

/**
 * Menu callback to display patterns details page
 */
// function patterns_info($pid = null) {
//   if (!is_numeric($pid)) {
//     drupal_set_message(t('You must specify a pattern.'));
//     return;
//   }
//
//   $pattern = patterns_get_pattern($pid);
//
//   $output = '';
//   return $output;
// }



// function patterns_disable_pattern($pid) {
//     $form['pid'] = array(
//     '#type' => 'value',
//     '#value' => $pid
//   );
//
//   $pattern = patterns_get_pattern($pid);
//
//   return confirm_form($form, t('Proceed with disabling pattern %pattern?', array('%pattern' => $pattern->title)), 'admin/patterns', '');
// }

//function patterns_process_modules($modules, $op = 'enable') {
//  // Enable at the beginning of the pattern. Disable at the end.
//  for($i=0;$module=$modules[$i];$i++) {
//    if (($op == 'enable' && $module['delete']) || ($op == 'disable' && !$module['delete'])) {
//      unset($modules[$i]);
//    }
//  }
//
//  patterns_invoke($empty, 'tag modules');
//  $error = patterns_invoke($modules, 'pre-validate');
//
//  // Error validating modules
//  if ($error) {
//    return $error;
//  }
//
//  patterns_invoke($modules, 'prepare');
//}

// function patterns_disable_pattern_submit($form_id, $form_values) {
//   $pid = $form_values['pid'];
//   $pattern = patterns_get_pattern($pid);
//
//   if (patterns_execute_pattern($pattern, true, true)) {
//     return 'admin/patterns';
//   }
// }

