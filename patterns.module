<?php


require_once 'includes/config.inc';
require_once 'includes/io.inc';
require_once 'includes/parser.inc';
require_once 'includes/utils.inc';
require_once 'includes/servers.inc';


define('PATTERNS_SUCCESS', 1);
define('PATTERNS_WARN', 0);
define('PATTERNS_ERR', -1);

define('PATTERNS_CREATE', 'create');
define('PATTERNS_MODIFY', 'modify');
define('PATTERNS_DELETE', 'delete');

/**
 * @file
 * Enables extremely simple adding/removing features to your site with minimal to no configuration.
 *
 * It works by reading a pattern file and then creating a form which contains already the values for 
 * specific elements. The form is then validated and submitted, exactly as the 'submit' button was
 * pressed from the browser window.
 *
 * The following steps (operations) are performed sequentially:
 *
 * * Preparation Phase 
 * -------------------
 *
 *  - 'prepare':      - Transform the patterns tags into the actual element of the form to be submitted. 
 *                    - Add eventual standard values which are missing (this makes writing the pattern
 *                      easier and more synthetic).
 *                    - No errors are raised here.
 *
 *  - 'validate':      - Validate the data for the form_id and raise errors, if any.
 *
 *
 * * Batch Phase
 * -----------------
 *
 * 
 *  // NOT USED NOW: Check if we need it later
 *  
 * - 'form_id':       - Returns the form_id to call for the specific operation. If an array is returned
 *                      the form_id(s) are called sequentially.
 * 
 * - 'build':         - Get the form data for the action. This can either just be the form values, or 
 *                      it can be the full //form_state object//. If a string is returned, the batch phase terminates
 *                      and the string will be displayed. This way there is no Form API involved.
 *                      
 * - 'params':        - Get any extra parameters required by the form function.
 * 
 *
 * * Execution Phase      
 * -----------------
 *  drupal_form_submit() is called
 *  
 *  
 * - 'cleanup':       - cleanup operations are performed, if any.
 * 
 *    
 * * Post Batch
 * ---------------   
 *  
 * // NOT USED NOW: Check if we need it later   
 * - 'identifiers':    - ????? Get any primary identifiers from the action for further actions to take advantage of
 *  
 *  
 *  
 * 
 * 
 */

/**
 * @todo:
 * @ Load (some) of the includes only when really needed
 * @ When you modify a pattern you always need to reload the main pattern page, so it noticed that the pattern is actually changed. In confirm form it is too late.
 * @ Enable pattern configurations
 * @ **done**Enable actions to see ids created/updated from other actions inside the pattern (tokens?)
 * @ **semi-done** Reset patterns
 * @ Enable components to analyze the current pattern for better validation
 * @ Allow module version restricting
 * @ Put in functionality to auto-download modules (and the correct version)
 * @ Enable backups before running patterns and reverting back to those backups
 * @ Implement a progress meter
 * @ Handle default values better to allow for absolute minimal actions
 * @ Enable interactive actions by allowing patterns to resume from a saved position
 * @ Implement an export feature for all available form_ids
 * @ Allow resuming failed patterns
 * @ In the pattern details, list any sub-patterns directly on the patterns listing page
 * @ Create a Pattern class (?) check performance
 * @ Increase performaces, it seems still slow.
 * @ Check core.php.inc 
 */



/**
 * Implementation of hook_menu().
 */
function patterns_menu() {
  $items = array();

  $items['admin/patterns'] = array(
    'title' => 'Patterns',
    'description' => 'Administer patterns available for your site',
    'page callback' => 'patterns_list',
    'access arguments' => array('administer patterns')
  );
  $items['admin/patterns/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10
  );
  
  // Ste: was
  // $items['admin/patterns/edit'] = array(
  $items['admin/patterns/edit/%'] = array(
    'title' => 'Edit Pattern',
    'page callback' => 'patterns_edit_page',
    //'page callback' => 'drupal_get_form',
     // Ste: was
     // 'page arguments' => array('patterns_edit'),
    //'page arguments' => array('patterns_edit', 3),
    'page arguments' => array(3),
    'access arguments' => array('administer patterns'),
    'type' => MENU_CALLBACK
  );
  $items['admin/patterns/enable'] = array(
    'title' => 'Enable Pattern',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('patterns_enable_pattern'),
    'access arguments' => array('administer patterns'),
    'type' => MENU_CALLBACK
  );
  $items['admin/patterns/publish'] = array(
    'title' => 'Publish Pattern',
    'page callback' => 'patterns_publish_pattern',
    'access arguments' => array('administer patterns'),
    'type' => MENU_CALLBACK
  );
  $items['admin/patterns/unpublish'] = array(
    'title' => 'Unpublish Pattern',
    'page callback' => 'patterns_unpublish_pattern',
    'access arguments' => array('administer patterns'),
    'type' => MENU_CALLBACK
  );
  $items['patterns.xml'] = array(
    'title' => 'Published Patterns',
    'page callback' => 'patterns_feed',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK
  );

  $items['admin/patterns/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('patterns_settings'),
    'access arguments' => array('administer patterns'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10
  );

  $items['admin/patterns/get'] = array(
    'title' => 'Download Pattern Source',
    'page callback' => 'patterns_get_source',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK
  );
  
  $items['admin/patterns/validate'] = array(
    'title' => 'Validate Pattern YAML Source',
    'page callback' => 'patterns_validate_service',
    'access arguments' => array('administer patterns'),
    'type' => MENU_CALLBACK
  );
  
  

  //     $items[] = array('path' => 'admin/patterns/configure',
  //       'title' => t('Configure Pattern'),
  //       'callback' => 'drupal_get_form',
  //       'callback arguments' => array('patterns_configure_pattern'),
  //       'type' => MENU_CALLBACK
  //     );

  //     $items[] = array('path' => 'admin/patterns/info',
  //       'title' => t('Pattern Details'),
  //       'callback' => 'patterns_info',
  //       'type' => MENU_CALLBACK
  //     );

  //     $items[] = array('path' => 'admin/patterns/disable',
  //       'access' => user_access('administer patterns'),
  //       'title' => t('Disable Pattern'),
  //       'callback' => 'drupal_get_form',
  //       'callback arguments' => array('patterns_disable_pattern'),
  //       'type' => MENU_CALLBACK
  //     );

  $items['admin/patterns/modules'] = array(
    'title' => 'Pattern Modules',
    'page callback' => 'patterns_modules_page',
    'access arguments' => array('administer patterns'),
    'type' => MENU_CALLBACK
  );

  //     $items[] = array('path' => 'admin/patterns/revert',
  //       'access' => user_access('administer patterns'),
  //       'title' => t('Revert Pattern'),
  //       'callback' => 'patterns_revert',
  //       'type' => MENU_CALLBACK
  //     );


  $items['admin/patterns/import'] = array(
    'title' => 'Import',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('patterns_import_source'),
    'access arguments' => array('administer patterns'),
    'type' => MENU_LOCAL_TASK
  );
  $items['admin/patterns/import/source'] = array(
    'title' => 'Import Source Code',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10
  );
  $items['admin/patterns/import/file'] = array(
    'title' => 'Import File',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('patterns_import_file'),
    'access arguments' => array('administer patterns'),
    'type' => MENU_LOCAL_TASK
  );
  $items['admin/patterns/import/url'] = array(
    'title' => 'Import from URL',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('patterns_import_url'),
    'access arguments' => array('administer patterns'),
    'type' => MENU_LOCAL_TASK
  );
  $items['admin/patterns/server'] = array(
    'title' => 'Patterns Server',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('patterns_import_server'),
    'access arguments' => array('administer patterns'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -5
  );

  return $items;
}




/**
 * First function to be called for displaying the pattern page.
 * 
 */
function patterns_list() {
  
  drupal_add_css(drupal_get_path('module', 'patterns') . '/patterns.css');
  drupal_add_js(drupal_get_path('module', 'patterns') . '/patterns.js');

  // Load the the pattern handlers from compontents directory
  // or from modules which implement hook_patterns
  patterns_load_components();
  
  // Load the patterns from files or from database
  $patterns = patterns_get_patterns();
  
  if (empty($patterns)) {
    return t('No patterns available.');
    
  } 
  
  $header = array(t('Title'), t('Status'), t('Version'), t('Actions'));

  // List all patterns
  $rows = array();
  
  foreach ($patterns as $pid => $pattern) {
    $actions = array();
    
    // Build Run/Re-Run/Update pattern links
    if (!$pattern->status) {
      $actions[] =  l(t('Run'), 'admin/patterns/enable/' . $pid);
    }
    elseif ($pattern->enabled >= $pattern->updated) {
      $actions[] =  l(t('Re-Run'), 'admin/patterns/enable/' . $pid);
    }
    else {
      $actions[] = l(t('Run Update'), 'admin/patterns/enable/' . $pid);
    }
    // Edit Link
    $actions[] = l(t('Edit'), 'admin/patterns/edit/' . $pid);
    
    //Publish/Unpublish link
    if (variable_get('patterns_allow_publish', FALSE)) {
      $actions[] = $pattern->public ? l(t('Unpublish'), 'admin/patterns/unpublish/' . $pid) : l(t('Publish'), 'admin/patterns/publish/' . $pid);
    }
    
    $actions = implode('&nbsp;&nbsp;', $actions);

    
    //      $title = l($pattern->title, 'admin/patterns/info/'. $pid, array('attributes' => array('class' => 'pattern-title', 'id' => 'pid-'. $pid)));
    $title = '<span id="pid-' . $pid . '" class="pattern-title">' . $pattern->title . '</span>';
    //     $view_more = '<div>'. t('Clik on pattern title to see more details.') .'</div>';
    $info = array();
    $info[] = t('Author:') . ' ' . @$pattern->info['author'];
    $info[] = t('Email:') . ' ' . @$pattern->info['author_email'];
    $info[] = t('Web:') . ' ' . @$pattern->info['author_website'];
    $author = theme('item_list', array('items' => $info));
    //    $title .= '<div id="pid-'. $pid .'-info" class="pattern-info">'. $author . $pattern->description . $view_more .'</div>';
    $title .= '<div id="pid-' . $pid . '-info" class="pattern-info">' . $author . $pattern->description . '</div>';
    
    $cells = array();
    $cells[] = array('data' => $title, 'class' => 'title');
    $cells[] = array('data' => $pattern->status ? t('Enabled') : t('Disabled'), 'class' => 'status');
    $cells[] = array('data' => @$pattern->info['version'], 'class' => 'version');
    $cells[] = array('data' => $actions, 'class' => 'actions');
    
    // Group patterns by category
    $category = $pattern->info['category'] ? $pattern->info['category'] : t('Other');
    
    $rows[$category][] = $cells;
  }

  // Builds as many fieldsets as pattern categories
  // and plot tables with the rows we created before
  ksort($rows);
  $output = '';
  foreach ($rows as $title => $category) {
    $fieldset = array('element' => array(
      '#title' => t($title),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
      '#children' => t($title), 
      '#value' => theme('table', array('rows' => $category, 'attributes' => array('class' => 'patterns-list'))),
    ));
    $output .= theme('fieldset', $fieldset);
  }

  return $output;
}

/**
 * 
 * Callback function of the path /enable/%
 * It prompts the user with a submenu of options regarding default behavior
 * with sub-patterns.
 * 
 * @TODO: find a way to skip this in pattern_list, to quickly execute the pattern
 * 
 * @param array $form the form array
 * @param array $form_state the state of the array
 * @param mixed $pid
 */
function patterns_enable_pattern($form, &$form_state, $pid) {
  $form['pid'] = array(
    '#type' => 'value',
    '#value' => $pid,
  );
  
  $options_mode = array(
    'extend' => 'Extend',
    'runover' => 'Run-Over',
  );
  
  $form['execution'] = array(
    '#type' => 'radios',
    '#title' => t('Execution mode:'),
    '#description' => t('Extend mode can only add new feature to your web-site, Run-over can also delete. At the moment \'Extend\' is the only mode permitted.'),
    '#options' => $options_mode,
    '#default_value' => 'extend',
    '#disabled' => 'true',
  );
  
//  $form['mode'] = array(
//    '#suffix' => '<div>',
//    '#markup' => 'Execution mode is <strong>Extend</strong>.',
//    '#prefix' => '</div>',
//  );
  
  $options = array(
    'first-update' => t('only if disabled or if updated since last run (recommended)'),  
    'always' => t('always'),
    'update' => t('only if updated since last run'),
    'first' => t('only if disabled'),
    'never' => t("don't run sub-patterns at all"),
  );
  
  $form['run-subpatterns'] = array(
    '#type' => 'radios',
    '#title' => t('Run sub-patterns:'),
    '#description' => t("Decide when to run sub-patterns that are called by the currently run pattern. If unsure, stick to recommended setting. Note that your choice won't have any effect if your pattern doesn't contain sub-patterns or if this setting has been defined within the pattern file itself."),
    '#options' => $options,
    '#default_value' => 'first-update',
  );
  
  $disclaimer = t('Please be sure to backup your site before running a pattern. Patterns are not guaranteed to be reversable in case they do not execute well or if unforseen side effects occur.');

  $pattern = patterns_get_pattern($pid);
  // TODO: check if $patterns === FALSE

  return confirm_form($form, t('Proceed with running pattern %pattern?', array('%pattern' => $pattern->title)), 'admin/patterns', $disclaimer);
}


/**
 * Takes the values from the form enable_pattern and starts the
 * whole process by calling execute_pattern
 * 
 * @param $form form
 * @param $form_state form_state
 */
function patterns_enable_pattern_submit($form, &$form_state) {
  $pid = $form_state['values']['pid'];

  patterns_load_components();
  $pattern = patterns_get_pattern($pid);

  patterns_start_engine($pattern, $form_state['values']);

  $form_state['redirect'] = 'admin/patterns';
}


/**
 * 
 * The beginning of the whole Patterns logic. Starts the execution in 'batch'
 * mode (default) or 'php' mode, which makes things easier for debugging.
 * 
 * @param stdClass $pattern Pattern object as loaded by patterns_get_pattern()
 * @param array $params Parameters for executing the pattern. Array format as follows:
 * 
 * 
 * pid => Pid of the pattern as it is in the database  
 * run-subpatterns => ['first-update', always','update','first','never']
 * 
 * If coming from form_confirm some other parameters are addes, such as:
 * confirm [1] 
 * submit  [Confirm] 
 * form_build_id 
 * form_token  
 * form_id 
 * op  [Confirm] 
 * 
 * @param mixed $mode ['batch','php'] 
 */
function patterns_start_engine($pattern, $params = array(), $mode = 'batch') {
  
  //require_once 'includes/core.'.$mode.'.inc';
  module_load_include('inc', 'patterns', 'includes/core.' . $mode);
  
  if (!function_exists('patterns_execute_pattern') || !is_object($pattern)) return FALSE;

  return patterns_execute_pattern($pattern, $params);
}



///**
// * Preparing and prevalidating the action tags as they are written 
// * in the pattern file. Concretely, it invokes operations 'prepare', 
// * and 'prevalidate' on the pattern component. 
// * 
// * @param array $actions
// * @param array $actions_map
// * @return array $result array containing the description of eventual errors
// */
//function patterns_prepare_actions(&$actions, $actions_map) {
//
//  $result = array('success' => TRUE);
//
//  if (empty($actions)) return $result;
//
//  patterns_load_components();
//
//  // Keep a list of which modules handle what tags
//  $tag_modules = patterns_invoke($empty, 'tag modules');
//
//  
//  // Ste: No module implements CONFIG now. None will in the future
//  
//  // TODO Finish basic setup and execution of the 'config' operation
//  // TODO Make a better streamlined config framework process. For instance collect form_ids
//  // from here and give the form_id and matching data to the 'build' process
//  //foreach ($actions as $key => &$data) {
//  // if (($config = patterns_invoke($actions[$key], 'config')) && !empty($config)) {
//  //    patterns_config_data($data, $config);
//  //  }
//  //}
//
//  $errors = array();
//  
//  /////////////////////////////////////////////
//  // Prepare actions for validation/processing
//  /////////////////////////////////////////////
//  foreach ($actions as $key => &$data) {
//    patterns_invoke($actions[$key], 'prepare');
//  }
//
//
//  //////////////////////////////////////////////////////
//  // Pre validate tags with their appropriate components
//  //////////////////////////////////////////////////////
//  foreach ($actions as $key => &$data) {
//
//    $action_location = patterns_locate_action($key, $actions_map);
//    $index = $action_location['key'];
//    $pattern_title = $action_location['title'];
////    $pattern_file = $action_location['file'];
//
//    if (!array_key_exists($data['tag'], $tag_modules)) {
//      $errors[] = t('Action #%num (%tag) in pattern %title: <%tag> is not a valid tag', array('%num' => $index+1, '%tag' => $data['tag'], '%title' => $pattern_title));
//    }
//    else {
//      $error = patterns_invoke($actions[$key], 'prevalidate');
//      if ($error) {
//        $errors[] = t('Action #%num (%tag) in pattern %title: !msg', array('!msg' => $error, '%num' => $index+1, '%tag' => $data['tag'], '%title' => $pattern_title));
//      }
//    }
//  }
//
//  if (count($errors)) {
//    $message = t('Errors encountered during pre-processing:') . '<br/>' . implode('<br/>', $errors);
//    $result['success'] = FALSE;
//    $result['error_message'] = $message;
//  }
//
//  return $result;
//}

// @TODO: Take care of updating all the methods: the order of the parameters 
// $op and &$data have been switched

// @TODO: Take care patterns_invoke does not return any more the tagmodules index
// use patterns_get_tagmodules_index() instead.

/**
 * Execute hook_patterns with the given operation and return the 
 * results. 
 * 
 * It also builds up, if necessary, the list of 
 * available action-tags and binds them to the correct module.
 * 
 * @param array $data the 
 * @param mixed $op operation to be performed by hook_patterns()
 * @param mixed $form_id name of the form to be passed to hook_patterns().
 * @param array $a extra parameters to pass to hook_patterns()
 * 
 * @return array $return an array packed by patterns_results
 */
//function patterns_invoke($op, &$data, $form_id = NULL, &$a = NULL) {
// TODO: update documdntation
function patterns_invoke($hook, $action, &$data = NULL, $form_id = NULL, &$a = NULL) {
  
  $tag_modules = patterns_get_tagmodules_index();

  // Unsetting it while the module performs operations
  $tag = $data['tag'];
  unset($data['tag']);
  
  if (!isset($tag_modules[$tag])){
    // TODO: Handle invalid tag.
  }
  $module = $tag_modules[$tag]['module'];
  $func = $module . '_patterns_' . $hook;

  // @TODO: Check returning false if the func does not exist.
  // Returns FALSE if the function is not existing.
  $return = FALSE;
  
  if (function_exists($func)) {
    if ($form_id) {
      $return = $func($action, $form_id, $data, $a);
    }
    else {
      $return = $func($action, $tag, $data, $a);
    }
  }

  // Check if the output is correctly formatted, and eventually tries to correct it
  if (!_patterns_is_patterns_results($return)) {
    
    if ($return === TRUE) {
      $return = array('status' => PATTERNS_SUCCESS);  
    }
    else if ($return === FALSE) {
      $msg = t('Unspecified error occurred in %func', array('%func'=>$func));
      $return = patterns_results (PATTERNS_ERR, $msg);
    }
    else {
      $msg = t('The return value of %func is not properly formatted', array('%func'=>$func));
      $return = patterns_results (PATTERNS_ERR, $msg);
    }
  }
  $data['tag'] = $tag;
  return $return;
  
}

/**
 * Creates the list of modules implementing the pattern hook. Additional 
 * information is provided such as the files or the forms needed by the tag.
 * 
 *  @param mixed $tag if set, only information about this specific tag is returned.
 *  @param mixed $id if set, only this particular bit of information is returned.
 *  Allowed values for $id are: 'descr', PATTERNS_CREATE, PATTERNS_MODIFY,  
 *  PATTERNS_DELETE, and 'files'
 *  
 *  @TODO: Attention: the return values has changed. Before was an array of tag=>module
 *  now you get the info with tag['module']
 *  
 *  @return array $tag_modules The tag_modules index built according to the parameters
 */
function patterns_get_tagmodules_index($tag_name = NULL, $id = NULL) {
  static $tag_modules;
  
  // Index not yet built 
  if (!is_array($tag_modules)) { 
    // Get a list of tags and their modules
    foreach (module_implements('patterns') as $module) {
      $tags = module_invoke($module, 'patterns','tags'); // TODO: the third parameter 'tags' has to go away once migration is completed
      if (!empty($tags)) {
        foreach ($tags as $tag => $value) {
          // Add the reference to the module within the information which each
          // module is already returning
          $value['module'] = $module;
          $tag_modules[$tag] = $value;
        }
      }
    }
  } 
  
  return _patterns_scan_tagmodules_index ($tag_modules, $tag_name, $id);
}

function _patterns_scan_tagmodules_index ($tagmodules, $tag, $id) {
  
  if (empty($tag)) {
    return $tagmodules;
  }
  else if (empty($action)) {
    return $tagmodules[$tag];
  }
  else {
    return $tagmodules[$tag][$id];
  }
}


function _patterns_rearrange_data($data, $parent = '') {
  $numeric = array();
  $count = 0;

  foreach ($data as $key => $value) {
    if (isset($value['value'])) {
      if ($value['value'] == 'false') {
        $value['value'] = FALSE;
      }
      elseif ($value['value'] == 'true') {
        $value['value'] = TRUE;
      }
    }

    if (is_numeric($key) && is_array($value) && count($value) == 2 && isset($value['tag']) && isset($value['value'])) {
      unset($data[$key]);
      if (isset($data[$value['tag']])) {
        $numeric[] = $value['tag'];
        $data[$count++] = $data[$value['tag']];
        $data[$count++] = $value['value'];
        unset($data[$value['tag']]);
      }
      elseif (in_array($value['tag'], $numeric)) {
        $data[$count++] = $value['value'];
      }
      else {
        $data[$value['tag']] = $value['value'];
      }
    }
    elseif (is_numeric($key)) {
      $tag = $value['tag'];
      unset($value['tag']);
      $data[$tag][] = _patterns_rearrange_data($value, $tag);
      unset($data[$key]);
    }
  }

  foreach ($data as $key => $value) {
    if (is_array($value) && count($value) == 1 && $value[0]) {
      $data[$key] = $data[$key][0];
    }
  }

  // This workaround enables us to define numeric keys in XML by
  // prefixing the number with single character. E.g <n0>value</n0>
  // will result in 0 => 'value' (first character of the key will be removed).
  if (isset($data['_numeric_keys'])) {
    unset($data['_numeric_keys']);
    foreach ($data as $key => $value) {
      $data[substr($key, 1)] = $value;
      unset($data[$key]);
    }
  }

  return $data;
}


function patterns_exit($destination = NULL) {
  $batch =& batch_get();
  if (variable_get('patterns_form_helper', FALSE) && $_SESSION['patterns_form_helper'] && !$destination && empty($batch)) {
    if (module_exists('devel')) {
      //dpm($_SESSION['patterns_form_helper']);
      kprint_r($_SESSION['patterns_form_helper']);
    }
    else {
      print theme('patterns_form_helper', $_SESSION['patterns_form_helper']['form_id'], $_SESSION['patterns_form_helper']['form_values']);
    }

  }
}


/**
 * Function callback
 */
function _patterns_modify_value(&$form) {
  foreach ($form as $key => $value) {
    if (is_array($value) && isset($value['#type']) && $value['#type'] == 'value') {
      $form[$key]['#default_value'] = $value['#value'];
      unset($form[$key]['#value']);
    }
    elseif (is_array($value)) {
      _patterns_modify_value($form[$key]);
    }
  }
}

/**
 * Recurse an array and replace with tokens
 * @ This is used instead of array_walk_recursive because
 *   of some strange issues with token_get_values failing.
 */
function _patterns_recurse_tokens(&$object, $identifiers) {
  foreach ($object as $key => $value) {
    if (is_array($value)) {
      _patterns_recurse_tokens($object[$key], $identifiers);
    }
    elseif (is_scalar($value)) {
      $old_key = $key;
      _patterns_replace_tokens($object[$key], $key, $identifiers);

      // The key was changed, change it
      if ($old_key != $key) {
        $keys = array_keys($object);
        $keys[array_search($old_key, $keys)] = $key;
        $object = array_combine($keys, array_values($object));
      }
    }
  }
}

/**
 * Array walk callback to replace tokens inside form values
 */
function _patterns_replace_tokens(&$a, &$b, $identifiers = array()) {
  static $count = 0;

  // Replace IDs with identifiers from the current executing pattern
  if (preg_match('/@([a-zA-Z0-9_]+)@/', $a, $match)) {
    $a = str_replace($match[0], $identifiers[$match[1]], $a);
  }
  if (preg_match('/__([a-zA-Z0-9_]+)__/', $b, $match)) {
    $b = str_replace($match[0], $identifiers[$match[1]], $a);
  }

  // Replace tokens
  // Ste: was
  //$a = token_replace($a, 'global', NULL, '@', '@');
  //$b = token_replace($b, 'global', NULL, '__', '__');\
  
  //$a = token_replace($a, 'global', NULL, '@', '@');
  //$b = token_replace($b, 'global', NULL, '__', '__');
  
  
}



function theme_patterns_form_helper_menu($forms) {
  $output = '<ul class="patterns-form-menu">';

  foreach ($forms as $form_id => $values) {
    $output .= '<li class="patterns-form-menu-item">' . $form_id . '</li>';
  }

  $output .= '</li>';

  return $output;
}

function theme_patterns_form_helper($form_id, $values) {

  $output = '<div class="patterns-form" id="patterns-form-' . $form_id . '">';

  $output .= '<div class="patterns-form-title">' . t('Form values for %key', array('%key' => $form_id)) . '</div>';

  foreach ($values as $key => $value) {
    $output .= '<div class="patterns-form-item"><div class="patterns-form-key">' . $key . ' => </div>';
    $output .= '<div class="patterns-form-value">' . print_r($value, TRUE) . '</div></div>';
  }

  $output .= '</div>';

  return $output;
}

/**
 * Implementation of hook_theme().
 */
function patterns_theme() {
  return array(
    'patterns_form_helper' => array(
      'arguments' => array('form_id' => NULL, 'values' => NULL),
  ),
    'patterns_form_helper_menu' => array(
      'forms' => NULL
  )
  );
}

/**
 * Make some modifications to the form values based on the form
 * In particular, make sure form elements with #options and #multiple
 * set the keys of the array as the key of the value as how FAPI does it,
 * but XML of course does not.
 */
function patterns_sync_form_values($args) {
  $form_id = $args[0];
  
  // this functionality is not working well with 
  // node forms (create/update node)
  // so skip them until this issue is fixed 
  if (strpos($form_id, 'node_form') !== FALSE) {
    return;
  }
    
  // References inside the form_state can cause potential problems,
  // so we'll ensure no references to outside data exists
  $form_state = unserialize(serialize($args[1]));
  $form_values = $form_state['values'];
  unset($args[1]['values']);

  // Get the fully built fapi object with cloned form_state.
  // We need to do this with a separate form_state because
  // this can mess up the form values if they are setup incorrectly
  // (it'll get fixed here)
  $form = call_user_func_array('drupal_retrieve_form', $args);
  drupal_prepare_form($form_id, $form, $form_state);
  $form = form_builder($form_id, $form, $form_state);

  // Loop through all form values looking for #options
  $queue = array(&$form);

  while (!empty($queue)) {
    $check = &$queue[0];
    array_shift($queue);

    // Skip disabled items
    if ($check['#disabled']) {
      continue;
    }

    // Set default values for everything that the form is expecting values for.
    // This can save work in the components as well as avoid bugs when a module
    // expects values to be there that are not.
    // Do not set default values when it is the type of value that a form submit
    // would not set data in $_POST for. Like selects with no options or unchecked
    // checkboxes
    if ($check['#input'] && isset($check['#default_value']) &&
        !($check['#type'] == 'select' && empty($check['#options'])) &&
        !(in_array($check['#type'], array('checkbox', 'checkboxes')) && empty($check['#default_value']))) {
      $match = &$form_values;
      $found = TRUE;
      foreach ($check['#parents'] as $path) {
        if (!isset($match[$path])) {
          $found = FALSE;
          $match[$path] = array();
        }
        // If this is not an array, the data was probably not completed properly
        // in the pattern.
        if (!is_array($match)) {
          $message = t('Invalid pattern syntax at: !path. Expecting more child elements.', array('!path' => implode('->', $check['#parents'])));
          patterns_error_handler(1, $message, '', '');
          return;
        }
        $match = &$match[$path];
      }

      // Set the default value unless it is a type of value that would originally
      // not be set in $_POST during form submit, like empty selects
      if (!$found) {
        $check['#missing_in_pattern'] = TRUE;
        $match = $check['#default_value'];
      }
    }

    if (!empty($check['#options'])) {
      $scalar = FALSE;
      if ((!$check['#tree'] && !$check['#multiple']) || (isset($check['#multiple']) && !$check['#multiple']) || in_array($check['#type'], array('radio', 'radios'))) {
        $scalar = TRUE;
      }

      // Find possible corresponding data in form values
      $match = &$form_values;
      $found = TRUE;
      foreach ($check['#parents'] as $path) {
        if (isset($match[$path])) {
          $match = &$match[$path];
        }
        else {
          $found = FALSE;
          break;
        }
      }

      if ($found && isset($match)) {
        // Check if we are overwriting or not.
        //
        // First, if the pattern value is there, but empty, we obviously
        // should be overwriting. Next is to check if overwrite was specified
        // manually
        $overwrite = FALSE;
        if (!$check['#missing_in_pattern'] && (empty($match) || (is_array($match) && !empty($match['overwrite'])))) {
          $overwrite = TRUE;
          if (is_array($match) && isset($match['overwrite'])) {
            unset($match['overwrite']);
          }
        }

        $delete = FALSE;
        if (is_array($match) && !empty($match['delete'])) {
          $delete = TRUE;
          unset($match['delete']);
        }
        
        // If overwriting, start the values array with all the
        // possible values but empty. We will possibly fill them
        // in with default values on update actions. Select types
        // do not work when empty, non-selected, values are set
        if (!$scalar && $overwrite && $check['#type'] != 'select') {
          $values = $check['#options'];
          foreach ($values as &$v) {
            $v = '';
          }
        }
        else {
          $values = array();
        }

        if (!$overwrite && !empty($check['#default_value'])) {
          foreach ((array)$check['#default_value'] as $value) {
            $values[$value] = $value;
          }

          // Make sure we are still restricted to values available in #options
          $values = array_intersect_key($values, $check['#options']);
        }

        // Flatten out the options in case it is trying to use optgroups
        $options = patterns_options_flatten($check['#options']);

        foreach ((array)$match as $value) {
          $key = array_search($value, $options);

          // If the supplied value is an actual options value (not the label) use that
          if ((is_string($value) || is_int($value)) && array_key_exists($value, $options)) {
            $values[$value] = $delete ? 0 : $value;
          }
          // Or if the supplied value matches an options label, use that option
          elseif ($key !== FALSE) {
            $values[$key] = $delete ? 0 : $key;
          }
          // If we are trying to set an invalid value, at least select
          // the first value for select forms since it is impossible to
          // not select a good value there
          elseif ($check['#type'] == 'select') {
            reset($options);
            $values[key($options)] = key($options);
          }
        }

        // If we are not on a multiple/tree form, the value should be singular/not an array.
        // We make sure to use the last value here because the last value will absolutely
        // be the user/pattern supplied value as opposed to the default_value
        if ($scalar) {
          $match = end($values);
        }
        else {
          $match = $values;
        }
      }
    }

    foreach (element_children($check) as $element) {
      $queue[] = &$check[$element];
    }
  }

  // Make sure the new form_values will be used in the real executions
  $args[1]['values'] = $form_values;
}

/**
 * Take a $data and $config object and adjust $data
 * based on the supplied configuration
 *
 * TODO Look for ways to optimize and increase performance
 */
function patterns_config_data(&$data, $configs) {
  foreach ($configs as $path => $config) {
    // An alias key requires multiple paths
    // for each alias and then a #real set
    // to change all of them to the same key
    // TODO test #alias
    if ($config['#alias'] && is_array($config['#alias'])) {
      $tokens = array_slice(preg_split('/(?<!=)\/(?![a-z]*\])/', $path), 1);
      $real = end($tokens);

      // Check for the real key
      $matches = patterns_array_fetch($path, $data);

      // If the real key was not found, get the aliases
      if (empty($matches)) {
        if (!$config['#key']) {
          $config['#key'] = $real;
        }
        foreach ($config['#alias'] as $alias) {
          $tokens[count($tokens)-1] = $alias;
          $matches += patterns_array_fetch('/' . implode('/', $tokens), $data);
        }
      }
    }
    else {
      $matches = patterns_array_fetch($path, $data);
    }

    // If no matches were found and it is a required element
    // return an error
    if (empty($matches) && $config['#required']) {
      $error = TRUE;
    }

    foreach ($matches as &$match) {
      // Collect form_ids here.
      // TODO Think of a better way to migrate components form_id operations here
      if ($config['#form_id']) {
        patterns_config_form_ids($data['tag'], $config['#form_id'], $match);
      }

      // Make sure values that should be arrays are set as such
      if ($config['#array'] && !array_key_exists(0, $match['item'])) {
        if (is_null($match['item']) || (is_array($match['item'] && empty($match['item'])))) {
          $match['item'] = array();
        }
        else {
          $match['item'] = array($match['item']);
        }

        // Update the context object to reflect new changes
        $match = _patterns_array_context($match['item'], $match);
      }

      // Change the key of this match. Can get the key value via xpath as well.
      // Any duplicate keys will return an error
      if ($config['#key']) {
        // Check that a single match is found via this xpath and that the resulting value is scalar
        if ($config['#key']{0} == '/' && ($sub_matches = patterns_array_fetch($config['#key'], $match['item'], $match)) && count($sub_matches) == 1 && is_scalar($sub_matches[0]['item'])) {
          // an xpath from the matched item is used to get the key value
          $new_key = $sub_matches[0]['item'];
        }
        elseif ($config['#default key']) {
          $new_key = $config['#default key'];
        }
        elseif ($config['#key']{0} == '/') {
          // Could not find the appropriate key value from the xpath
          $error = TRUE;
        }
        else {
          // Set the key to a static value. Typically used for allowing more user readable keys
          $new_key = $config['#key'];
        }

        if ($new_key && array_key_exists($new_key, $match['parent']['item'])) {
          // The new key already exists.
          $error = TRUE;
        }
        elseif ($new_key) {
          $key = $match['key'];
          $match['parent']['item'][$new_key] = $match['item'];
          // TODO This is buggy. Skip for now.
          if (is_int($key) && FALSE) {
            array_splice($match['parent']['item'], $key, 1);
          }
          else {
            unset($match['parent']['item'][$key]);
          }

          // Update the parent context object to reflect new changes
          $match['parent'] = _patterns_array_context($match['parent']['item'], $match['parent']);

          // Update to the new current match
          for ($i=0, $total = count($match['parent']); $i < $total; $i++) {
            if ($match['parent'][$i]['key'] == $new_key) {
              $match = &$match['parent'][$i];
              break;
            }
          }
        }
      }

      // Create empty key elements if they don't exist but should (and are not required)
      // This is useful when using 'move' to ensure that the destination exists
      if ($config['#create'] && is_array($match['item']) && !array_key_exists($config['#create'], $match['item'])) {
        $match['item'][$config['#create']] = $config['#create value'];
      }

      // Move(or copy) this match to somewhere else in the object. If more than one destination
      // match is found, this value is copied to each one
      // TODO Make move automatically create the destination if it doesn't exist
      // TODO Support move in (put inside array) and move to (replace) actions
      if (!empty($match['parent']) && ($config['#move']{0} == '/' && ($dest_path = $config['#move']) && ($op = 'move')) ||
      ($config['#copy']{0} == '/' && ($dest_path = $config['#copy']) && ($op = 'copy'))) {
        $dests = patterns_array_fetch($dest_path, $match['item'], $match);
        $parent = &$match['parent'];
        $obj = $match['item'];

        foreach ($dests as $dest) {
          // Can't move to items that are not an array
          if (!is_array($dest['item'])) {
            continue;
          }
          if (!is_int($match['key'])) {
            $dest['item'][$match['key']] = $obj;
          }
          else {
            $dest['item'][] = $obj;
          }

          // Update the dest object to reflect the change
          $dest = _patterns_array_context($dest['item'], $dest);
        }

        if ($op == 'move') {
          if (!is_int($match['key'])) {
            unset($parent['item'][$match['key']]);
          }
          else {
            array_splice($parent['item'], $match['key'], 1);
          }

          // Update the parent object to reflect the change (removal)
          $parent = _patterns_array_context($parent['item'], $parent);
          unset($match);
        }
      }
    }
  }
}


function patterns_set_error_handler() {
  // set custom error handler
  set_error_handler('patterns_error_handler');
  // trigger dummy error
  // this will be used as a refrence to determine if any real error
  // occured during the pattern execution
  @trigger_error('patterns_error');
}

function patterns_restore_error_handler() {
  restore_error_handler();
}

/**
 * Custom error handler used only during patterns execution
 * in order to catch and properly handle PHP errors.
 * Based on drupal_error_handler().
 */
function patterns_error_handler($errno, $message, $filename, $line, $context) {

  // @TODO  E_DEPRECATED does not work in PHP < 5.3
  if ($errno & (E_ALL ^ E_NOTICE)) { // ^ E_DEPRECATED)) {

    $types = array(
      1 =>array('Error', WATCHDOG_ERROR),
      2 => array('Warning', WATCHDOG_WARNING),
      4 => array('Parse error', WATCHDOG_ERROR), 
      8 => array('Notice', WATCHDOG_NOTICE),
      16 => array('Core error', WATCHDOG_ERROR),
      32 => array('Core warning', WATCHDOG_WARNING),
      64 => array('Compile error', WATCHDOG_ERROR),
      128 =>  array('Compile warning', WATCHDOG_WARNING),
      256 => array('User error', WATCHDOG_ERROR),
      512 => array('User warning', WATCHDOG_WARNING),
      1024 => array('User notice', WATCHDOG_NOTICE),
      2048 => array('Strict warning', WATCHDOG_DEBUG),
      4096 => array('Recoverable fatal error', WATCHDOG_ERROR),
     );

    // For database errors, we want the line number/file name of the place that
    // the query was originally called, not _db_query().
    if (isset($context['DB_ERROR'])) {
      $backtrace = array_reverse(debug_backtrace());

      // List of functions where SQL queries can originate.
      $query_functions = array('db_query', 'pager_query', 'db_query_range', 'db_query_temporary', 'update_sql');

      // Determine where query function was called, and adjust line/file
      // accordingly.
      foreach ($backtrace as $index => $function) {
        if (in_array($function['function'], $query_functions)) {
          $line = $backtrace[$index]['line'];
          $filename = $backtrace[$index]['file'];
          break;
        }
      }
    }

    // 'patterns_error' is not a real error and should be skipped
    if ($message != 'patterns_error') {
      watchdog('php', '%message in %file on line %line.', array('%error' => $types[$errno][0], '%message' => $message, '%file' => $filename, '%line' => $line), $types[$errno][1]);
      if($types[$errno][1]==WATCHDOG_ERROR)
        patterns_error_set_last(array('message' => $message, 'type' => $errno, 'file' => $filename, 'line' => $line));
    }
  }
  return TRUE;
}

function patterns_error_set_last($error = NULL) {
  static $last_error = array();

  if (isset($error)) {
    $last_error = $error;
  }
  return $last_error;
}

/**
 * Check and report PHP errors during patterns execution
 *
 * @param $op
 *   operation within hook_patterns() during which error occured
 * @param $key
 *   number of the action currently proccessed
 * @param $description
 *   description of the current action
 * @param $pattern_title
 *   title of the pattern currently proccessed
 * @param $pattern_file
 *   path to pattern file currently proccessed
 * @return
 *   error message if new error encountered
 *   FALSE if there are no new errors
 *
 */
function patterns_error_get_last($op, $key, $description, $pattern_title, $pattern_file) {
  $error = patterns_error_set_last();

  if (!empty($error) && $error['message'] != 'patterns_error') {
   // $types = array(1 => 'error', 2 => 'warning', 4 => 'parse error', 8 => 'notice', 16 => 'core error', 32 => 'core warning', 64 => 'compile error', 128 => 'compile warning', 256 => 'user error', 512 => 'user warning', 1024 => 'user notice', 2048 => 'strict warning', 4096 => 'recoverable fatal error');
       $types = array(
      1 =>array('Error', WATCHDOG_ERROR),
      2 => array('Warning', WATCHDOG_WARNING),
      4 => array('Parse error', WATCHDOG_ERROR), 
      8 => array('Notice', WATCHDOG_NOTICE),
      16 => array('Core error', WATCHDOG_ERROR),
      32 => array('Core warning', WATCHDOG_WARNING),
      64 => array('Compile error', WATCHDOG_ERROR),
      128 =>  array('Compile warning', WATCHDOG_WARNING),
      256 => array('User error', WATCHDOG_ERROR),
      512 => array('User warning', WATCHDOG_WARNING),
      1024 => array('User notice', WATCHDOG_NOTICE),
      2048 => array('Strict warning', WATCHDOG_DEBUG),
      4096 => array('Recoverable fatal error', WATCHDOG_ERROR),
     );
  	
  	$php_error_message = $types[$error['type']][0] . ': ' . $error['message'] . ' in ' . $error['file'] . ' on line ' . $error['line'] . '.';
    $message = t('Pattern %title (%pattern_file)<br/>Action #%key: %description (op "%op")<br/>PHP error occured:<br/>%error', array('%key' => $key, '%title' => $pattern_title, '%op' => $op, '%description' => $description, '%error' => $php_error_message, '%pattern_file' => $pattern_file));
    return $message;
  }
  return FALSE;
}

/**
 * Custom implementation of drupal_process_form()
 *
 * Enables validation to be performed for each executed form
 * by calling our custom _patterns_validate_form() function
 * see issue: http://drupal.org/node/260934
 */
function _patterns_process_form($form_id, &$form, &$form_state) {
  //$form_state['values'] = array(); // ????

  $form = form_builder($form_id, $form, $form_state);

  // Only process the form if it is programmed or the form_id coming
  // from the POST data is set and matches the current form_id.
  //Ste: was
  //if ((!empty($form['#programmed'])) || (!empty($form['#post']) && (isset($form['#post']['form_id']) && ($form['#post']['form_id'] == $form_id)))) {
  if (TRUE) {
    _patterns_validate_form($form_id, $form, $form_state);

    // form_clean_id() maintains a cache of element IDs it has seen,
    // so it can prevent duplicates. We want to be sure we reset that
    // cache when a form is processed, so scenerios that result in
    // the form being built behind the scenes and again for the
    // browser don't increment all the element IDs needlessly.
    // Ste: was
    //form_clean_id(NULL, TRUE);
    drupal_clean_css_identifier(NULL);
    
    //Ste: was
    //if ((!empty($form_state['submitted'])) && !form_get_errors() && empty($form_state['rebuild'])) {
    if (TRUE) { 
      $form_state['redirect'] = NULL;
      form_execute_handlers('submit', $form, $form_state);

      // We'll clear out the cached copies of the form and its stored data
      // here, as we've finished with them. The in-memory copies are still
      // here, though.
      if (variable_get('cache', CACHE_DISABLED) == CACHE_DISABLED && !empty($form_state['values']['form_build_id'])) {
        cache_clear_all('form_' . $form_state['values']['form_build_id'], 'cache_form');
        cache_clear_all('storage_' . $form_state['values']['form_build_id'], 'cache_form');
      }

      // If batches were set in the submit handlers, we process them now,
      // possibly ending execution. We make sure we do not react to the batch
      // that is already being processed (if a batch operation performs a
      // drupal_execute).
      if ($batch =& batch_get() && !isset($batch['current_set'])) {
        // The batch uses its own copies of $form and $form_state for
        // late execution of submit handers and post-batch redirection.
        $batch['form'] = $form;
        $batch['form_state'] = $form_state;
        $batch['progressive'] = !$form['#programmed'];
        batch_process();
        // Execution continues only for programmatic forms.
        // For 'regular' forms, we get redirected to the batch processing
        // page. Form redirection will be handled in _batch_finished(),
        // after the batch is processed.
      }

      // If no submit handlers have populated the $form_state['storage']
      // bundle, and the $form_state['rebuild'] flag has not been set,
      // we're finished and should redirect to a new destination page
      // if one has been set (and a fresh, unpopulated copy of the form
      // if one hasn't). If the form was called by drupal_execute(),
      // however, we'll skip this and let the calling function examine
      // the resulting $form_state bundle itself.
      if (!$form['#programmed'] && empty($form_state['rebuild']) && empty($form_state['storage'])) {
        drupal_redirect_form($form, $form_state['redirect']);
      }
    }
  }
}

/**
 * Custom implementation of drupal_validate_form()
 *
 * Removed static variable that prevented same form_id to be
 * validated more then once during a single page request
 */
function _patterns_validate_form($form_id, $form, &$form_state) {
  // If the session token was set by drupal_prepare_form(), ensure that it
  // matches the current user's session.
  if (isset($form['#token'])) {
    if (!drupal_valid_token($form_state['values']['form_token'], $form['#token'])) {
      // Setting this error will cause the form to fail validation.
      form_set_error('form_token', t('Validation error, please try again. If this error persists, please contact the site administrator.'));
    }
  }

  _form_validate($form, $form_state, $form_id);
}


function patterns_rearrange_data($pattern) {
  foreach ($pattern as $key => $value) {
    if (is_string($key)) {
      unset($pattern[$key]);
    }
    else {
      if ($value['tag'] == 'actions') {
        $pattern[$key] = patterns_rearrange_data($value);
        $pattern[$key]['tag'] = 'actions';
      }
      else {
        $pattern[$key] = _patterns_rearrange_data($value);
      }
    }
  }

  return $pattern;
}

/**
 * For use with token replacement
 */
function patterns_array_map($function, $array, $params) {
  $new_array = array();
  foreach ($array as $key => $value) {
    if (is_array($value)) {
      $new_array[$key] = patterns_array_map($function, $value, $params);
    }
    else {
      $params[] = $key;
      $key = call_user_func_array($function, $params);
      array_pop($params);
      $params[] = $value;
      $new_array[$key] = call_user_func_array($function, $params);
      array_pop($params);
    }
  }
  return $new_array;
}

///**
// * Return an array with detailed information about the pattern.
// * @TODO improve the doc of patterns_get_pattern_details
// * 
// * @param stdClass $pattern Pattern object as loaded by patterns_get_pattern()
// * @param $recursive ??
// * @param $pids ??
// */
//function patterns_get_pattern_details_new ($pattern, $recursive = FALSE, &$pids = array()) {
//
//  // prevent infinite recursion
//  // Disabled! Infinite recursion is possible!
//  // This allows the same pattern to be re-executed with different parameters
//  // TODO: detect recursion, and protect users from it
//  // if (in_array($pattern->pid, $pids)) return array();
//  
//  
//  // Get the list of sections
//  $standard_sections = array('info','modules');
//  $pattern_array = $pattern->pattern;
//  $custom_sections = array_diff_key($pattern_array,$standard_sections);
//  
//  
//  //$pids[$pattern->pid] = $pattern->pid;
//  //$actions = !empty($pattern->pattern['actions']) ? $pattern->pattern['actions'] : array();
//  
// 
//
////  $patterns[$pattern->pid] = (array) $pattern;
////  $patterns[$pattern->pid] = array_merge($patterns[$pattern->pid], $patterns[$pattern->pid]['pattern']['info']);
////  unset($patterns[$pattern->pid]['pattern']);
//
//  
//   // @TODO: check this
//   $modules = !empty($pattern->pattern['modules']) ? $pattern->pattern['modules'] : array();
//  
//  //if ($recursive) {
//    $result = array('modules' => $modules, 'info' => $patterns);
//
//    
//    foreach ($custom_sections as $section) {
//      
//      
//      if ($action['tag'] == 'pattern') {
//        // determine pattern name
//        if (!empty($action['value'])) {
//          $name = $action['value'];
//        }
//        elseif (!empty($action['name'])) {
//          $name = $action['name'];
//        }
//        if (!$p = patterns_get_pattern($name)) {
//          // just give a warning and try to continue
//          drupal_set_message(t('Action #%key in %file: Pattern %pattern not found.<br/>Pattern execution will try to continue without it.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'warning');
//          continue;
//        }
//        
//        
//        
//        // Decide if sub-pattern needs to be run based on the mode defined within the pattern or selected in UI at the time of form submission
//        // @TODO: UI setting should be able to override a setting defined within the pattern 
////        $modes = array('first-update', 'always', 'update', 'first', 'never');
////        if (!empty($action['run']) && in_array($action['run'], $modes)) {
////          $mode = $action['run'];
////        }
////        else {
////          $mode = $pattern->subpatterns_run_mode;
////        }
////
////        switch ($mode) {
////          case 'never':
////            // don't run sub-pattern 
////            drupal_set_message(t('Action #%key in %file: Pattern %pattern not ran because the pattern was set to be skipped.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'status'); 
////            continue 2;
////            break;
////          case 'first':
////            // Only run on first run
////            if ($p->status) {
////              drupal_set_message(t('Action #%key in %file: Pattern %pattern not ran because the pattern was set to execute only on the first run.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'status');
////              continue 2;
////            }
////            break;
////          case 'update':
////            // Only run on pattern update
////            if ($p->enabled >= $p->updated) {
////              drupal_set_message(t('Action #%key in %file: Pattern %pattern not ran because the pattern was set to execute only on pattern update.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'status');
////              continue 2;
////            }
////            break;
////          case 'first-update':
////            // Only run on first run or pattern update
////            if ($p->status && $p->enabled >= $p->updated) {
////              drupal_set_message(t('Action #%key in %file: Pattern %pattern not ran because the pattern was set to execute only on first run or update.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'status');
////              continue 2;
////            }
////            break;
////          case 'always':
////          default:
////            // Run always
////            break;
////        }
////
////        $a = patterns_get_pattern_details($p, TRUE, $pids);
////        if (is_array($a) && empty($a)) {
////          // An empty array is returned on infinite recursion detection
////          drupal_set_message(t('Action #%key in %file: Infinite recursion detected while attempting to run pattern %pattern.<br/>Pattern execution will try to continue without it.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'warning');
////          continue;
////        }
////        // we replace for tokens in the generated pattern
////        // this is just a proof of concept, so far
////        if (!empty($action['parameters'])) {
////          $tokens = array_keys($action['parameters']);
////          $values = array_values($action['parameters']);
////          // give tokens their delimiters
////          foreach ($tokens as &$token) {
////            $token = "__" . $token . "__";
////          }
////          $a = patterns_array_map('str_replace', $a, array($tokens, $values));
////        }
////        // array_merge doesn't preserve numeric array keys
////        // so we handle 'info' separately
////        $info = $result['info'];
////        $result = array_merge_recursive($result, $a);
////        $result['info'] = $info + $a['info'];
////      }
////      else {
////        $result['actions'][] = $action;
////        $result['actions_map'][] = array(
////          'pid'   => $pattern->pid,
////          'index' => $key,
////        );
////      }
////    }
//    $result['modules'] = array_merge(array_unique($result['modules']));
//    // Remove pid from recursion stack
//    //unset($pids[$pattern->pid]);
//    return $result;
//  }
//  // Remove pid from recursion stack
//  //unset($pids[$pattern->pid]);
//  
//  
//  
//  return array('actions' => $actions, 'modules' => $modules, 'info' => $patterns);
//}


/**
 * Return an array with detailed information about the pattern(s) referenced in
 * the pattern files (included).
 * 
 * @param stdClass $pattern Pattern object as loaded by patterns_get_pattern()
 * @param $recursive if the directive include is valid
 * @param $pids ??
 * 
 * @return array $details array('pid1'=>$details, 'pid2'=>$details...)
 */
function patterns_get_pattern_details($pattern, $recursive = FALSE, &$pids = array()) {

  $scan = _patterns_scan_pattern($pattern->pattern);
  
  $details = array();
  
  if (_patterns_validate_patternscan($scan)) {
    $details['info'] = $pattern->pattern['info'];
    $details['sections'] = array_intersect_key($pattern->pattern,$scan['other_sections']);
    $details['modules'] = ($scan['modules'] > 0 ) ? $pattern->pattern['modules'] : array();
  }
  
  return array($pattern->pid => $details);
  
  ////////////////////////////////////////////////////////////////
  // IMPORTANT
  // The part below is for handling the include tag. Not used now;
  ////////////////////////////////////////////////////////////////
  
  
  // prevent infinite recursion
  // Disabled! Infinite recursion is possible!
  // This allows the same pattern to be re-executed with different parameters
  // TODO: detect recursion, and protect users from it
  // if (in_array($pattern->pid, $pids)) return array();
  $pids[$pattern->pid] = $pattern->pid;


  $patterns[$pattern->pid] = (array)$pattern;
  $patterns[$pattern->pid] = array_merge($patterns[$pattern->pid], $patterns[$pattern->pid]['pattern']['info']);
  unset($patterns[$pattern->pid]['pattern']);

  
  
  if ($recursive) {
    $result = array('modules' => $modules, 'info' => $patterns);

    foreach ($actions as $key => $action) {
      if ($action['tag'] == 'pattern') {
        // determine pattern name
        if (!empty($action['value'])) {
          $name = $action['value'];
        }
        elseif (!empty($action['name'])) {
          $name = $action['name'];
        }
        if (!$p = patterns_get_pattern($name)) {
          // just give a warning and try to continue
          drupal_set_message(t('Action #%key in %file: Pattern %pattern not found.<br/>Pattern execution will try to continue without it.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'warning');
          continue;
        }
        
        // Decide if sub-pattern needs to be run based on the mode defined within the pattern or selected in UI at the time of form submission
        // @TODO: UI setting should be able to override a setting defined within the pattern 
        $modes = array('first-update', 'always', 'update', 'first', 'never');
        if (!empty($action['run']) && in_array($action['run'], $modes)) {
          $mode = $action['run'];
        }
        else {
          $mode = $pattern->subpatterns_run_mode;
        }

        switch ($mode) {
          case 'never':
            // don't run sub-pattern 
            drupal_set_message(t('Action #%key in %file: Pattern %pattern not ran because the pattern was set to be skipped.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'status'); 
            continue 2;
            break;
          case 'first':
            // Only run on first run
            if ($p->status) {
              drupal_set_message(t('Action #%key in %file: Pattern %pattern not ran because the pattern was set to execute only on the first run.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'status');
              continue 2;
            }
            break;
          case 'update':
            // Only run on pattern update
            if ($p->enabled >= $p->updated) {
              drupal_set_message(t('Action #%key in %file: Pattern %pattern not ran because the pattern was set to execute only on pattern update.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'status');
              continue 2;
            }
            break;
          case 'first-update':
            // Only run on first run or pattern update
            if ($p->status && $p->enabled >= $p->updated) {
              drupal_set_message(t('Action #%key in %file: Pattern %pattern not ran because the pattern was set to execute only on first run or update.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'status');
              continue 2;
            }
            break;
          case 'always':
          default:
            // Run always
            break;
        }

        $a = patterns_get_pattern_details($p, TRUE, $pids);
        if (is_array($a) && empty($a)) {
          // An empty array is returned on infinite recursion detection
          drupal_set_message(t('Action #%key in %file: Infinite recursion detected while attempting to run pattern %pattern.<br/>Pattern execution will try to continue without it.', array('%key' => $key+1, '%file' => $pattern->title, '%pattern' => $name)), 'warning');
          continue;
        }
        // we replace for tokens in the generated pattern
        // this is just a proof of concept, so far
        if (!empty($action['parameters'])) {
          $tokens = array_keys($action['parameters']);
          $values = array_values($action['parameters']);
          // give tokens their delimiters
          foreach ($tokens as &$token) {
            $token = "__" . $token . "__";
          }
          $a = patterns_array_map('str_replace', $a, array($tokens, $values));
        }
        // array_merge doesn't preserve numeric array keys
        // so we handle 'info' separately
        $info = $result['info'];
        $result = array_merge_recursive($result, $a);
        $result['info'] = $info + $a['info'];
      }
      else {
        $result['actions'][] = $action;
        $result['actions_map'][] = array(
          'pid'   => $pattern->pid,
          'index' => $key,
        );
      }
    }
    $result['modules'] = array_merge(array_unique($result['modules']));
    // Remove pid from recursion stack
    //unset($pids[$pattern->pid]);
    return $result;
  }
  // Remove pid from recursion stack
  //unset($pids[$pattern->pid]);
  return array('actions' => $actions, 'modules' => $modules, 'info' => $patterns);
}


function patterns_debug_batch($var = NULL) {
  $var = print_r($var, TRUE);
  $var = str_replace(" ", '&nbsp;', $var);
  $var = str_replace("\n", "<br />", $var);
  print drupal_to_js(array('status' => 0, 'data' => $var));
  exit;
}


// function patterns_revert($pid) {
//   if ($name = db_result(db_query('SELECT name FROM {patterns} WHERE pid = "%d"', $pid))) {
//     $path = file_create_path(variable_get('patterns_save_xml', 'patterns') .'/enabled/'. $name .'.xml');
//     $new = db_result(db_query('SELECT file FROM {patterns} WHERE pid = "%d"'));
//   }
//   else {
//     drupal_set_message(t('The pattern you specified does not exist.'), 'error');
//     drupal_goto('admin/patterns');
//   }
//
//   if (file_exists($path)) {
//     if (file_move($path, $new, FILE_EXISTS_REPLACE)) {
//       drupal_set_message(t('This pattern was reverted to the state it was at when it was enabled.'));
//       drupal_goto();
//     }
//   }
//   else {
//     drupal_set_message(t('The patterns enabled-state was not saved properly, therefore it cannot be reverted.'), 'error');
//   }
//
//   drupal_goto('admin/patterns');
// }

/**
 * Menu callback to display patterns details page
 */
// function patterns_info($pid = null) {
//   if (!is_numeric($pid)) {
//     drupal_set_message(t('You must specify a pattern.'));
//     return;
//   }
//
//   $pattern = patterns_get_pattern($pid);
//
//   $output = '';
//   return $output;
// }



// function patterns_disable_pattern($pid) {
//     $form['pid'] = array(
//     '#type' => 'value',
//     '#value' => $pid
//   );
//
//   $pattern = patterns_get_pattern($pid);
//
//   return confirm_form($form, t('Proceed with disabling pattern %pattern?', array('%pattern' => $pattern->title)), 'admin/patterns', '');
// }

//function patterns_process_modules($modules, $op = 'enable') {
//  // Enable at the beginning of the pattern. Disable at the end.
//  for($i=0;$module=$modules[$i];$i++) {
//    if (($op == 'enable' && $module['delete']) || ($op == 'disable' && !$module['delete'])) {
//      unset($modules[$i]);
//    }
//  }
//
//  patterns_invoke($empty, 'tag modules');
//  $error = patterns_invoke($modules, 'prevalidate');
//
//  // Error validating modules
//  if ($error) {
//    return $error;
//  }
//
//  patterns_invoke($modules, 'prepare');
//}

// function patterns_disable_pattern_submit($form_id, $form_values) {
//   $pid = $form_values['pid'];
//   $pattern = patterns_get_pattern($pid);
//
//   if (patterns_execute_pattern($pattern, true, true)) {
//     return 'admin/patterns';
//   }
// }

